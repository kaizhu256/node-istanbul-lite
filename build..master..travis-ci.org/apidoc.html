<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    overflow-wrap: break-word;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/kaizhu256/node-istanbul-lite"

    >istanbul-lite (2020.5.31)</a>
</h1>
<h4>this zero-dependency package will provide browser-compatible version of istanbul coverage-tool (v0.4.5), with working web-demo</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite">module istanbul-lite</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>Instrumenter
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.__istanbul_module">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>__istanbul_module
            <span class="apidocSignatureSpan">(id = &apos;&apos;, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.assertOrThrow">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>assertOrThrow
            <span class="apidocSignatureSpan">(passed, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.cliRun">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>cliRun
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.coalesce">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>coalesce
            <span class="apidocSignatureSpan">(...argList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.coverageMerge">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>coverageMerge
            <span class="apidocSignatureSpan">(coverage1 = {}, coverage2 = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.coverageReportCreate">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>coverageReportCreate
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>esprima.Parser
            <span class="apidocSignatureSpan">(options, input, startPos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Position">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>esprima.Position
            <span class="apidocSignatureSpan">(line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.Controller">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>estraverse.Controller
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.fsReadFileOrDefaultSync">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>fsReadFileOrDefaultSync
            <span class="apidocSignatureSpan">(pathname, type, dflt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.fsRmrfSync">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>fsRmrfSync
            <span class="apidocSignatureSpan">(pathname)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.fsWriteFileWithMkdirpSync">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>fsWriteFileWithMkdirpSync
            <span class="apidocSignatureSpan">(pathname, data, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.identity">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>identity
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.instrumentInPackage">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>instrumentInPackage
            <span class="apidocSignatureSpan">(code, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.instrumentSync">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>instrumentSync
            <span class="apidocSignatureSpan">(code, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.nop">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>nop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.objectAssignDefault">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>objectAssignDefault
            <span class="apidocSignatureSpan">(tgt = {}, src = {}, depth = 0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.hrtime">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>process.hrtime
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.require">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>require
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.require.resolve">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>require.resolve
            <span class="apidocSignatureSpan">(request, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.templateRender">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>templateRender
            <span class="apidocSignatureSpan">(template, dict, opt, ii)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">istanbul-lite.</span>timeExit</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>Instrumenter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>__istanbul_path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>escodegen</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>esprima</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>esprima.Parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>esprima.Position.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>estraverse</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>estraverse.Controller.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>esutils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>istanbul</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>local</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>process._events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>process.stderr</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>process.stdout</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.</span>require.extensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">istanbul-lite.</span>__dirname</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">istanbul-lite.</span>templateCoverageBadgeSvg</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">istanbul-lite.</span>templateCoverageReport</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.Instrumenter">module istanbul-lite.Instrumenter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.Instrumenter">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>Instrumenter
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.Instrumenter.prototype">module istanbul-lite.Instrumenter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.arrowBlockConverter">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>arrowBlockConverter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.branchIncrementExprAst">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>branchIncrementExprAst
            <span class="apidocSignatureSpan">(varName, branchIndex, down)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.branchLocationFor">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>branchLocationFor
            <span class="apidocSignatureSpan">(name, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.branchName">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>branchName
            <span class="apidocSignatureSpan">(type, startLine, pathLocations)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.conditionalBranchInjector">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>conditionalBranchInjector
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.convertToBlock">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>convertToBlock
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.coverExport">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>coverExport
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.coverFunction">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>coverFunction
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.coverMetaProperty">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>coverMetaProperty
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.coverStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>coverStatement
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.endIgnore">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>endIgnore
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.extractCurrentHint">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>extractCurrentHint
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.filterHints">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>filterHints
            <span class="apidocSignatureSpan">(comments)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.findLeaves">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>findLeaves
            <span class="apidocSignatureSpan">(node, accumulator, parent, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.fixColumnPositions">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>fixColumnPositions
            <span class="apidocSignatureSpan">(coverState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.functionName">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>functionName
            <span class="apidocSignatureSpan">(node, line, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.getPreamble">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>getPreamble
            <span class="apidocSignatureSpan">(sourceCode, emitUseStrict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.ifBlockConverter">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>ifBlockConverter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.ifBranchInjector">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>ifBranchInjector
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.instrument">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>instrument
            <span class="apidocSignatureSpan">(code, filename, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.instrumentASTSync">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>instrumentASTSync
            <span class="apidocSignatureSpan">(program, filename, originalCode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.instrumentSync">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>instrumentSync
            <span class="apidocSignatureSpan">(code, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.isUseStrictExpression">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>isUseStrictExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.lastFileCoverage">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>lastFileCoverage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.lastSourceMap">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>lastSourceMap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.locationsForNodes">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>locationsForNodes
            <span class="apidocSignatureSpan">(nodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.logicalExpressionBranchInjector">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>logicalExpressionBranchInjector
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.loopBlockConverter">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>loopBlockConverter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.maybeAddSkip">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>maybeAddSkip
            <span class="apidocSignatureSpan">(branchLocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.maybeAddType">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>maybeAddType
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.maybeSkipNode">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>maybeSkipNode
            <span class="apidocSignatureSpan">(node, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.paranoidHandlerCheck">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>paranoidHandlerCheck
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.skipInit">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>skipInit
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.skipLeft">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>skipLeft
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.splice">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>splice
            <span class="apidocSignatureSpan">(statements, node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.startIgnore">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>startIgnore
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.statementName">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>statementName
            <span class="apidocSignatureSpan">(location, initValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.switchBranchInjector">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>switchBranchInjector
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.switchCaseInjector">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>switchCaseInjector
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.withBlockConverter">
            function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>withBlockConverter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.cliDict">module istanbul-lite.cliDict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.cliDict.cover">
            function <span class="apidocSignatureSpan">istanbul-lite.cliDict.</span>cover
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.cliDict.instrument">
            function <span class="apidocSignatureSpan">istanbul-lite.cliDict.</span>instrument
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.cliDict.report">
            function <span class="apidocSignatureSpan">istanbul-lite.cliDict.</span>report
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.cliDict.test">
            function <span class="apidocSignatureSpan">istanbul-lite.cliDict.</span>test
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.escodegen">module istanbul-lite.escodegen</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">istanbul-lite.escodegen.</span>browser</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.escodegen.attachComments">
            function <span class="apidocSignatureSpan">istanbul-lite.escodegen.</span>attachComments
            <span class="apidocSignatureSpan">(tree, providedComments, tokens)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.escodegen.generate">
            function <span class="apidocSignatureSpan">istanbul-lite.escodegen.</span>generate
            <span class="apidocSignatureSpan">(node, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.escodegen.</span>FORMAT_DEFAULTS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.escodegen.</span>FORMAT_MINIFY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.escodegen.</span>Precedence</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.esprima">module istanbul-lite.esprima</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Node">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>Node
            <span class="apidocSignatureSpan">(parser, pos, loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>Parser
            <span class="apidocSignatureSpan">(options, input, startPos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Position">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>Position
            <span class="apidocSignatureSpan">(line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.SourceLocation">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>SourceLocation
            <span class="apidocSignatureSpan">(p, start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.TokContext">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>TokContext
            <span class="apidocSignatureSpan">(token, isExpr, preserveSpace, override, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Token">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>Token
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.TokenType">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>TokenType
            <span class="apidocSignatureSpan">(label, conf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.getLineInfo">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>getLineInfo
            <span class="apidocSignatureSpan">(input, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.isIdentifierChar">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>isIdentifierChar
            <span class="apidocSignatureSpan">(code, astral)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.isIdentifierStart">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>isIdentifierStart
            <span class="apidocSignatureSpan">(code, astral)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.isNewLine">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>isNewLine
            <span class="apidocSignatureSpan">(code, ecma2019String)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.parse">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>parse
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.parseExpressionAt">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>parseExpressionAt
            <span class="apidocSignatureSpan">(input, pos, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.tokenizer">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>tokenizer
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>defaultOptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>keywordTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>lineBreak</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>lineBreakG</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>nonASCIIwhitespace</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>tokContexts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>tokTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.esprima.Parser">module istanbul-lite.esprima.Parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.Parser">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>Parser
            <span class="apidocSignatureSpan">(options, input, startPos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.extend">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.</span>extend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.parse">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.</span>parse
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.parseExpressionAt">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.</span>parseExpressionAt
            <span class="apidocSignatureSpan">(input, pos, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.tokenizer">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.</span>tokenizer
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.esprima.Parser.prototype">module istanbul-lite.esprima.Parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.adaptDirectivePrologue">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>adaptDirectivePrologue
            <span class="apidocSignatureSpan">(statements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.afterTrailingComma">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>afterTrailingComma
            <span class="apidocSignatureSpan">(tokType, notNext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.braceIsBlock">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>braceIsBlock
            <span class="apidocSignatureSpan">(prevType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.buildBinary">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>buildBinary
            <span class="apidocSignatureSpan">(startPos, startLoc, left, right, op, logical)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.canInsertSemicolon">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>canInsertSemicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkExport">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkExport
            <span class="apidocSignatureSpan">(exports, name, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkExpressionErrors">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkExpressionErrors
            <span class="apidocSignatureSpan">(refDestructuringErrors, andThrow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkLVal">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkLVal
            <span class="apidocSignatureSpan">(expr, bindingType, checkClashes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkLocalExport">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkLocalExport
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkParams">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkParams
            <span class="apidocSignatureSpan">(node, allowDuplicates)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkPatternErrors">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkPatternErrors
            <span class="apidocSignatureSpan">(refDestructuringErrors, isAssign)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkPatternExport">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkPatternExport
            <span class="apidocSignatureSpan">(exports, pat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkPropClash">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkPropClash
            <span class="apidocSignatureSpan">(prop, propHash, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkUnreserved">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkUnreserved
            <span class="apidocSignatureSpan">(ref)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkVariableExport">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkVariableExport
            <span class="apidocSignatureSpan">(exports, decls)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkYieldAwaitInDefaultParams">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkYieldAwaitInDefaultParams
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.curContext">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>curContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.curPosition">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>curPosition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.currentScope">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>currentScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.currentThisScope">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>currentThisScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.currentVarScope">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>currentVarScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.declareName">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>declareName
            <span class="apidocSignatureSpan">(name, bindingType, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.eat">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>eat
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.eatContextual">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>eatContextual
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.enterScope">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>enterScope
            <span class="apidocSignatureSpan">(flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.exitScope">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>exitScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.expect">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>expect
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.expectContextual">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>expectContextual
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.finishNode">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>finishNode
            <span class="apidocSignatureSpan">(node, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.finishNodeAt">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>finishNodeAt
            <span class="apidocSignatureSpan">(node, type, pos, loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.finishOp">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>finishOp
            <span class="apidocSignatureSpan">(type, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.finishToken">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>finishToken
            <span class="apidocSignatureSpan">(type, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.fullCharCodeAtPos">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>fullCharCodeAtPos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.getToken">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>getToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.getTokenFromCode">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>getTokenFromCode
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.inGeneratorContext">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>inGeneratorContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.inNonArrowFunction">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>inNonArrowFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.initFunction">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>initFunction
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.initialContext">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>initialContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.insertSemicolon">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>insertSemicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.invalidStringToken">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>invalidStringToken
            <span class="apidocSignatureSpan">(position, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.isAsyncFunction">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>isAsyncFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.isAsyncProp">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>isAsyncProp
            <span class="apidocSignatureSpan">(prop)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.isContextual">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>isContextual
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.isDirectiveCandidate">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>isDirectiveCandidate
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.isLet">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>isLet
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.isSimpleAssignTarget">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>isSimpleAssignTarget
            <span class="apidocSignatureSpan">(expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.isSimpleParamList">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>isSimpleParamList
            <span class="apidocSignatureSpan">(params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.next">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>next
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.nextToken">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>nextToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parse">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseArrowExpression">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseArrowExpression
            <span class="apidocSignatureSpan">(node, params, isAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseAwait">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseAwait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseBindingAtom">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseBindingAtom
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseBindingList">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseBindingList
            <span class="apidocSignatureSpan">(close, allowEmpty, allowTrailingComma)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseBindingListItem">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseBindingListItem
            <span class="apidocSignatureSpan">(param)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseBlock">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseBlock
            <span class="apidocSignatureSpan">(createNewLexicalScope, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseBreakContinueStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseBreakContinueStatement
            <span class="apidocSignatureSpan">(node, keyword)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseClass">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseClass
            <span class="apidocSignatureSpan">(node, isStatement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseClassElement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseClassElement
            <span class="apidocSignatureSpan">(constructorAllowsSuper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseClassId">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseClassId
            <span class="apidocSignatureSpan">(node, isStatement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseClassMethod">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseClassMethod
            <span class="apidocSignatureSpan">(method, isGenerator, isAsync, allowsDirectSuper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseClassSuper">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseClassSuper
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseDebuggerStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseDebuggerStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseDoStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseDoStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseDynamicImport">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseDynamicImport
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseEmptyStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseEmptyStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExport">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExport
            <span class="apidocSignatureSpan">(node, exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExportSpecifiers">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExportSpecifiers
            <span class="apidocSignatureSpan">(exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExprAtom">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExprAtom
            <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExprList">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExprList
            <span class="apidocSignatureSpan">(close, allowTrailingComma, allowEmpty, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExprOp">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExprOp
            <span class="apidocSignatureSpan">(left, leftStartPos, leftStartLoc, minPrec, noIn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExprOps">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExprOps
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExprSubscripts">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExprSubscripts
            <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExpression">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExpression
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExpressionStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExpressionStatement
            <span class="apidocSignatureSpan">(node, expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseFor">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseFor
            <span class="apidocSignatureSpan">(node, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseForIn">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseForIn
            <span class="apidocSignatureSpan">(node, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseForStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseForStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseFunction">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseFunction
            <span class="apidocSignatureSpan">(node, statement, allowExpressionBody, isAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseFunctionBody">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseFunctionBody
            <span class="apidocSignatureSpan">(node, isArrowFunction, isMethod)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseFunctionParams">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseFunctionParams
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseFunctionStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseFunctionStatement
            <span class="apidocSignatureSpan">(node, isAsync, declarationPosition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseIdent">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseIdent
            <span class="apidocSignatureSpan">(liberal, isBinding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseIfStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseIfStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseImport">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseImport
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseImportSpecifiers">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseImportSpecifiers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseLabeledStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseLabeledStatement
            <span class="apidocSignatureSpan">(node, maybeName, expr, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseLiteral">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseLiteral
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseMaybeAssign">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseMaybeAssign
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors, afterLeftParse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseMaybeConditional">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseMaybeConditional
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseMaybeDefault">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseMaybeDefault
            <span class="apidocSignatureSpan">(startPos, startLoc, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseMaybeUnary">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseMaybeUnary
            <span class="apidocSignatureSpan">(refDestructuringErrors, sawUnary)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseMethod">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseMethod
            <span class="apidocSignatureSpan">(isGenerator, isAsync, allowDirectSuper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseNew">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseNew
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseObj">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseObj
            <span class="apidocSignatureSpan">(isPattern, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseParenAndDistinguishExpression">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseParenAndDistinguishExpression
            <span class="apidocSignatureSpan">(canBeArrow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseParenArrowList">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseParenArrowList
            <span class="apidocSignatureSpan">(startPos, startLoc, exprList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseParenExpression">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseParenExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseParenItem">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseParenItem
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseProperty">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseProperty
            <span class="apidocSignatureSpan">(isPattern, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parsePropertyName">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parsePropertyName
            <span class="apidocSignatureSpan">(prop)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parsePropertyValue">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parsePropertyValue
            <span class="apidocSignatureSpan">(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseRestBinding">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseRestBinding
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseReturnStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseReturnStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseSpread">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseSpread
            <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseStatement
            <span class="apidocSignatureSpan">(context, topLevel, exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseSubscript">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseSubscript
            <span class="apidocSignatureSpan">(base, startPos, startLoc, noCalls, maybeAsyncArrow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseSubscripts">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseSubscripts
            <span class="apidocSignatureSpan">(base, startPos, startLoc, noCalls)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseSwitchStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseSwitchStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseTemplate">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseTemplate
            <span class="apidocSignatureSpan">(ref)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseTemplateElement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseTemplateElement
            <span class="apidocSignatureSpan">(ref)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseThrowStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseThrowStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseTopLevel">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseTopLevel
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseTryStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseTryStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseVar">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseVar
            <span class="apidocSignatureSpan">(node, isFor, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseVarId">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseVarId
            <span class="apidocSignatureSpan">(decl, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseVarStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseVarStatement
            <span class="apidocSignatureSpan">(node, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseWhileStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseWhileStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseWithStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseWithStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseYield">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseYield
            <span class="apidocSignatureSpan">(noIn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.raise">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>raise
            <span class="apidocSignatureSpan">(pos, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.raiseRecoverable">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>raiseRecoverable
            <span class="apidocSignatureSpan">(pos, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readCodePoint">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readCodePoint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readEscapedChar">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readEscapedChar
            <span class="apidocSignatureSpan">(inTemplate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readHexChar">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readHexChar
            <span class="apidocSignatureSpan">(len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readInt">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readInt
            <span class="apidocSignatureSpan">(radix, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readInvalidTemplateToken">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readInvalidTemplateToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readNumber">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readNumber
            <span class="apidocSignatureSpan">(startsWithDot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readRadixNumber">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readRadixNumber
            <span class="apidocSignatureSpan">(radix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readRegexp">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readRegexp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readString">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readString
            <span class="apidocSignatureSpan">(quote)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readTmplToken">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readTmplToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_caret">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken_caret
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_dot">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken_dot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_eq_excl">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken_eq_excl
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_lt_gt">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken_lt_gt
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_mult_modulo_exp">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken_mult_modulo_exp
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_pipe_amp">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken_pipe_amp
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_plus_min">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken_plus_min
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_slash">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken_slash
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readWord">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readWord
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readWord1">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readWord1
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_alternative">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_alternative
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_classRanges">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_classRanges
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_disjunction">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_disjunction
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatAssertion">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatAssertion
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatAtom">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatAtom
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatAtomEscape">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatAtomEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatBackReference">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatBackReference
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatBracedQuantifier">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatBracedQuantifier
            <span class="apidocSignatureSpan">(state, noError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatCControlLetter">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatCControlLetter
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatCapturingGroup">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatCapturingGroup
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatCharacterClass">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatCharacterClass
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatCharacterClassEscape">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatCharacterClassEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatCharacterEscape">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatCharacterEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatClassAtom">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatClassAtom
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatClassControlLetter">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatClassControlLetter
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatClassEscape">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatClassEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatControlEscape">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatControlEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatControlLetter">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatControlLetter
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatDecimalDigits">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatDecimalDigits
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatDecimalEscape">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatDecimalEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatExtendedAtom">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatExtendedAtom
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatExtendedPatternCharacter">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatExtendedPatternCharacter
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatFixedHexDigits">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatFixedHexDigits
            <span class="apidocSignatureSpan">(state, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatGroupName">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatGroupName
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatHexDigits">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatHexDigits
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatHexEscapeSequence">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatHexEscapeSequence
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatIdentityEscape">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatIdentityEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatInvalidBracedQuantifier">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatInvalidBracedQuantifier
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatKGroupName">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatKGroupName
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatLegacyOctalEscapeSequence">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatLegacyOctalEscapeSequence
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatLoneUnicodePropertyNameOrValue">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatLoneUnicodePropertyNameOrValue
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatOctalDigit">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatOctalDigit
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatPatternCharacters">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatPatternCharacters
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatQuantifier">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatQuantifier
            <span class="apidocSignatureSpan">(state, noError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatQuantifierPrefix">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatQuantifierPrefix
            <span class="apidocSignatureSpan">(state, noError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatRegExpIdentifierName">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierName
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatRegExpIdentifierPart">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierPart
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatRegExpIdentifierStart">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierStart
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatRegExpUnicodeEscapeSequence">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatRegExpUnicodeEscapeSequence
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatReverseSolidusAtomEscape">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatReverseSolidusAtomEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatSyntaxCharacter">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatSyntaxCharacter
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatTerm">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatTerm
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatUncapturingGroup">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatUncapturingGroup
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatUnicodePropertyName">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyName
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatUnicodePropertyValue">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyValue
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatUnicodePropertyValueExpression">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyValueExpression
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatZero">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatZero
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_groupSpecifier">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_groupSpecifier
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_pattern">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_pattern
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_validateUnicodePropertyNameAndValue">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_validateUnicodePropertyNameAndValue
            <span class="apidocSignatureSpan">(state, name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_validateUnicodePropertyNameOrValue">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_validateUnicodePropertyNameOrValue
            <span class="apidocSignatureSpan">(state, nameOrValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.semicolon">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>semicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.shouldParseExportStatement">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>shouldParseExportStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.skipBlockComment">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>skipBlockComment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.skipLineComment">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>skipLineComment
            <span class="apidocSignatureSpan">(startSkip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.skipSpace">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>skipSpace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.startNode">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>startNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.startNodeAt">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>startNodeAt
            <span class="apidocSignatureSpan">(pos, loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.strictDirective">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>strictDirective
            <span class="apidocSignatureSpan">(start)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.toAssignable">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>toAssignable
            <span class="apidocSignatureSpan">(node, isBinding, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.toAssignableList">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>toAssignableList
            <span class="apidocSignatureSpan">(exprList, isBinding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.treatFunctionsAsVarInScope">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>treatFunctionsAsVarInScope
            <span class="apidocSignatureSpan">(scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.tryReadTemplateToken">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>tryReadTemplateToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.unexpected">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>unexpected
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.updateContext">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>updateContext
            <span class="apidocSignatureSpan">(prevType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.validateRegExpFlags">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>validateRegExpFlags
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.validateRegExpPattern">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>validateRegExpPattern
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.esprima.Position">module istanbul-lite.esprima.Position</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Position.Position">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>Position
            <span class="apidocSignatureSpan">(line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.esprima.Position.prototype">module istanbul-lite.esprima.Position.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.esprima.Position.prototype.offset">
            function <span class="apidocSignatureSpan">istanbul-lite.esprima.Position.prototype.</span>offset
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.estraverse">module istanbul-lite.estraverse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.Controller">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.</span>Controller
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.attachComments">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.</span>attachComments
            <span class="apidocSignatureSpan">(tree, providedComments, tokens)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.cloneEnvironment">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.</span>cloneEnvironment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.replace">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.</span>replace
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.traverse">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.</span>traverse
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.estraverse.</span>Syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.estraverse.</span>VisitorKeys</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.estraverse.</span>VisitorOption</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.estraverse.Controller">module istanbul-lite.estraverse.Controller</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.Controller.Controller">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.</span>Controller
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.estraverse.Controller.prototype">module istanbul-lite.estraverse.Controller.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.__execute">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>__execute
            <span class="apidocSignatureSpan">(callback, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.__initialize">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>__initialize
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.break">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.current">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>current
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.notify">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>notify
            <span class="apidocSignatureSpan">(flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.parents">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>parents
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.path">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>path
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.remove">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>remove
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.replace">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>replace
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.skip">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>skip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.traverse">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>traverse
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.type">
            function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.process">module istanbul-lite.process</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">istanbul-lite.process.</span>_exiting</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process._debugEnd">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_debugEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process._debugProcess">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_debugProcess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process._fatalException">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_fatalException
            <span class="apidocSignatureSpan">(er, fromPromise)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process._getActiveHandles">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_getActiveHandles
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process._getActiveRequests">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_getActiveRequests
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process._kill">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_kill
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process._linkedBinding">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_linkedBinding
            <span class="apidocSignatureSpan">(module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process._rawDebug">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_rawDebug
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process._startProfilerIdleNotifier">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_startProfilerIdleNotifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process._stopProfilerIdleNotifier">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_stopProfilerIdleNotifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process._tickCallback">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_tickCallback
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.abort">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>abort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.assert">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>assert
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.binding">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>binding
            <span class="apidocSignatureSpan">(module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.chdir">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>chdir
            <span class="apidocSignatureSpan">(directory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.cpuUsage">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>cpuUsage
            <span class="apidocSignatureSpan">(prevValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.cwd">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>cwd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.dlopen">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>dlopen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.emitWarning">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>emitWarning
            <span class="apidocSignatureSpan">(warning, type, code, ctor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.exit">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>exit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.getegid">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>getegid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.geteuid">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>geteuid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.getgid">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>getgid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.getgroups">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>getgroups
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.getuid">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>getuid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.hasUncaughtExceptionCaptureCallback">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>hasUncaughtExceptionCaptureCallback
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.hrtime">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>hrtime
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.initgroups">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>initgroups
            <span class="apidocSignatureSpan">(user, extraGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.kill">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>kill
            <span class="apidocSignatureSpan">(pid, sig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.memoryUsage">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>memoryUsage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.nextTick">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>nextTick
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.openStdin">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>openStdin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.reallyExit">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>reallyExit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.resourceUsage">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>resourceUsage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.setUncaughtExceptionCaptureCallback">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>setUncaughtExceptionCaptureCallback
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.setegid">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>setegid
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.seteuid">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>seteuid
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.setgid">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>setgid
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.setgroups">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>setgroups
            <span class="apidocSignatureSpan">(groups)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.setuid">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>setuid
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.umask">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>umask
            <span class="apidocSignatureSpan">(mask)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.uptime">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>uptime
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">istanbul-lite.process.</span>_eventsCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">istanbul-lite.process.</span>debugPort</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">istanbul-lite.process.</span>pid</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">istanbul-lite.process.</span>ppid</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.</span>_events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.</span>_preload_modules</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.</span>allowedNodeEnvironmentFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.</span>argv</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.</span>execArgv</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.</span>features</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.</span>mainModule</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.</span>moduleLoadList</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.</span>release</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.</span>stderr</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.</span>stdin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.</span>stdout</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.</span>versions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">istanbul-lite.process.</span>arch</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">istanbul-lite.process.</span>argv0</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">istanbul-lite.process.</span>execPath</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">istanbul-lite.process.</span>platform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">istanbul-lite.process.</span>title</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">istanbul-lite.process.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.process._events">module istanbul-lite.process._events</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process._events.warning">
            function <span class="apidocSignatureSpan">istanbul-lite.process._events.</span>warning
            <span class="apidocSignatureSpan">(warning)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process._events.</span>newListener</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process._events.</span>removeListener</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.process.hrtime">module istanbul-lite.process.hrtime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.hrtime.hrtime">
            function <span class="apidocSignatureSpan">istanbul-lite.process.</span>hrtime
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.hrtime.bigint">
            function <span class="apidocSignatureSpan">istanbul-lite.process.hrtime.</span>bigint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.process.stderr">module istanbul-lite.process.stderr</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>_hadError</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>_isStdio</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>allowHalfOpen</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>connecting</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.stderr._destroy">
            function <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>_destroy
            <span class="apidocSignatureSpan">(err, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.stderr.destroySoon">
            function <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>destroySoon
            <span class="apidocSignatureSpan">(err, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>_eventsCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>fd</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>_events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>_host</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>_parent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>_pendingData</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>_readableState</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>_server</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>_sockname</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>_writableState</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>server</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>_pendingEncoding</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>_type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.process.stdout">module istanbul-lite.process.stdout</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>_hadError</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>_isStdio</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>allowHalfOpen</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>connecting</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.stdout._destroy">
            function <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>_destroy
            <span class="apidocSignatureSpan">(err, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.process.stdout.destroySoon">
            function <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>destroySoon
            <span class="apidocSignatureSpan">(err, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>_eventsCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>fd</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>_events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>_host</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>_parent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>_pendingData</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>_readableState</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>_server</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>_sockname</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>_writableState</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>server</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>_pendingEncoding</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>_type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.require">module istanbul-lite.require</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.require.require">
            function <span class="apidocSignatureSpan">istanbul-lite.</span>require
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.require.resolve">
            function <span class="apidocSignatureSpan">istanbul-lite.require.</span>resolve
            <span class="apidocSignatureSpan">(request, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.require.</span>cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.require.</span>extensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">istanbul-lite.require.</span>main</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.require.extensions">module istanbul-lite.require.extensions</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.istanbul-lite.require.resolve">module istanbul-lite.require.resolve</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.require.resolve.resolve">
            function <span class="apidocSignatureSpan">istanbul-lite.require.</span>resolve
            <span class="apidocSignatureSpan">(request, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.istanbul-lite.require.resolve.paths">
            function <span class="apidocSignatureSpan">istanbul-lite.require.resolve.</span>paths
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite" id="apidoc.module.istanbul-lite">module istanbul-lite</a></h1>


    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter" id="apidoc.elem.istanbul-lite.Instrumenter">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>Instrumenter
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Instrumenter(options) {
    this.opts = options || {
        debug: false,
        walkDebug: false,
        coverageVariable: &apos;__coverage__&apos;,
        codeGenerationOptions: undefined,
        noAutoWrap: false,
        noCompact: false,
        embedSource: false,
        preserveComments: false,
        esModules: false
    };

    if (this.opts.esModules &amp;&amp; !this.opts.noAutoWrap) {
        this.opts.noAutoWrap = true;
        if (this.opts.debug) {
            console.log(&apos;Setting noAutoWrap to true as required by esModules&apos;);
        }
    }

    this.walker = new Walker({
        ArrowFunctionExpression: [ this.arrowBlockConverter ],
        ExpressionStatement: this.coverStatement,
        ExportNamedDeclaration: this.coverExport,
        BreakStatement: this.coverStatement,
        ContinueStatement: this.coverStatement,
        DebuggerStatement: this.coverStatement,
        ReturnStatement: this.coverStatement,
        ThrowStatement: this.coverStatement,
        TryStatement: [ this.paranoidHandlerCheck, this.coverStatement],
        VariableDeclaration: this.coverStatement,
        IfStatement: [ this.ifBlockConverter, this.coverStatement, this.ifBranchInjector ],
        ForStatement: [ this.skipInit, this.loopBlockConverter, this.coverStatement ],
        ForInStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
        ForOfStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
        WhileStatement: [ this.loopBlockConverter, this.coverStatement ],
        DoWhileStatement: [ this.loopBlockConverter, this.coverStatement ],
        SwitchStatement: [ this.coverStatement, this.switchBranchInjector ],
        SwitchCase: [ this.switchCaseInjector ],
        WithStatement: [ this.withBlockConverter, this.coverStatement ],
        FunctionDeclaration: [ this.coverFunction, this.coverStatement ],
        FunctionExpression: this.coverFunction,
        LabeledStatement: this.coverStatement,
        ConditionalExpression: this.conditionalBranchInjector,
        LogicalExpression: this.logicalExpressionBranchInjector,
        ObjectExpression: this.maybeAddType,
        MetaProperty: this.coverMetaProperty,
    }, this.extractCurrentHint, this, this.opts.walkDebug);

    //unit testing purposes only
    if (this.opts.backdoor &amp;&amp; this.opts.backdoor.omitTrackerSuffix) {
        this.omitTrackerSuffix = true;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.__istanbul_module" id="apidoc.elem.istanbul-lite.__istanbul_module">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>__istanbul_module
        <span class="apidocSignatureSpan">(id = &apos;&apos;, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Module(id = &apos;&apos;, parent) {
  this.id = id;
  this.path = path.dirname(id);
  this.exports = {};
  this.parent = parent;
  updateChildren(parent, this, false);
  this.filename = null;
  this.loaded = false;
  this.children = [];
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.assertOrThrow" id="apidoc.elem.istanbul-lite.assertOrThrow">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>assertOrThrow
        <span class="apidocSignatureSpan">(passed, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertOrThrow = function (passed, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will throw err.&lt;msg&gt; if &lt;passed&gt; is falsy
 */
</span>    if (passed) {
        return;
    }
    throw (
        (
            msg
            &amp;&amp; typeof msg.message === &quot;string&quot;
            &amp;&amp; typeof msg.stack === &quot;string&quot;
        )
        // if msg is err, then leave as is
        ? msg
        : new Error(
            typeof msg === &quot;string&quot;
            // if msg is a string, then leave as is
            ? msg
            // else JSON.stringify msg
            : JSON.stringify(msg, undefined, 4)
        )
    );
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.<span class="apidocCodeKeywordSpan">assertOrThrow</span>(undefined, new Error(
        &quot;cliRun - cannot parse comment in COMMAND &quot;
        + key
        + &quot;:\nnew RegExp(&quot;
        + JSON.stringify(opt.rgxComment.source)
        + &quot;).exec(&quot; + JSON.stringify(str).replace((
            /\\\\/g
        ), &quot;\u0000&quot;).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.cliRun" id="apidoc.elem.istanbul-lite.cliRun">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>cliRun
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cliRun = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run cli with given &lt;opt&gt;
 */
</span>    local.cliDict._eval = local.cliDict._eval || function () {
    /*
     * &lt;code&gt;
     * will eval &lt;code&gt;
     */
        globalThis.local = local;
        local.vm.runInThisContext(process.argv[3]);
    };
    local.cliDict._help = local.cliDict._help || function () {
    /*
     *
     * will print help
     */
        let commandList;
        let file;
        let packageJson;
        let str;
        let strDict;
        commandList = [
            {
                argList: &quot;&lt;arg2&gt;  ...&quot;,
                description: &quot;usage:&quot;,
                command: [
                    &quot;&lt;arg1&gt;&quot;
                ]
            }, {
                argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
                description: &quot;example:&quot;,
                command: [
                    &quot;--eval&quot;
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), &quot;&quot;);
        opt = Object.assign({}, opt);
        packageJson = require(&quot;./package.json&quot;);
        // validate comment
        opt.rgxComment = opt.rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020
(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        strDict = {};
        Object.keys(local.cliDict).sort().forEach(function (key, ii) {
            if (key[0] === &quot;_&quot; &amp;&amp; key !== &quot;_default&quot;) {
                return;
            }
            str = String(local.cliDict[key]);
            if (key === &quot;_default&quot;) {
                key = &quot;&quot;;
            }
            strDict[str] = strDict[str] || (ii + 2);
            ii = strDict[str];
            if (commandList[ii]) {
                commandList[ii].command.push(key);
                return;
            }
            try {
                commandList[ii] = opt.rgxComment.exec(str);
                commandList[ii] = {
                    argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
                    command: [
                        key
                    ],
                    description: commandList[ii][2]
                };
            } catch (ignore) {
                local.assertOrThrow(undefined, new Error(
                    &quot;cliRun - cannot parse comment in COMMAND &quot;
                    + key
                    + &quot;:\nnew RegExp(&quot;
                    + JSON.stringify(opt.rgxComment.source)
                    + &quot;).exec(&quot; + JSON.stringify(str).replace((
                        /\\\\/g
                    ), &quot;\u0000&quot;).replace((
                        /\\n/g
                    ), &quot;\\n\\\n&quot;).replace((
                        /\u0000/g
                    ), &quot;\\\\&quot;) + &quot;);&quot;
                ));
            }
        });
        str = &quot;&quot;;
        str += packageJson.name + &quot; (&quot; + packageJson.version + &quot;)\n\n&quot;;
        str += commandList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.command = elem.command.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(&quot; &quot;);
                elem.description = (
                    &quot;# COMMAND &quot;
                    + (elem.command[0] || &quot;&lt;none&gt;&quot;) + &quot;\n# &quot;
                    + elem.description
                );
            }
            return (
                elem.description + &quot;\n  &quot; + file
                + &quot;  &quo...</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.coalesce" id="apidoc.elem.istanbul-lite.coalesce">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>coalesce
        <span class="apidocSignatureSpan">(...argList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coalesce = function (...argList) {
<span class="apidocCodeCommentSpan">/*
 * this function will coalesce null, undefined, or &quot;&quot; in &lt;argList&gt;
 */
</span>    let arg;
    let ii;
    ii = 0;
    while (ii &lt; argList.length) {
        arg = argList[ii];
        if (arg !== null &amp;&amp; arg !== undefined &amp;&amp; arg !== &quot;&quot;) {
            break;
        }
        ii += 1;
    }
    return arg;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
if (commandList[ii]) {
    commandList[ii].command.push(key);
    return;
}
try {
    commandList[ii] = opt.rgxComment.exec(str);
    commandList[ii] = {
        argList: local.<span class="apidocCodeKeywordSpan">coalesce</span>(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.assertOrThrow(undefined, new Error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.coverageMerge" id="apidoc.elem.istanbul-lite.coverageMerge">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>coverageMerge
        <span class="apidocSignatureSpan">(coverage1 = {}, coverage2 = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coverageMerge = function (coverage1 = {}, coverage2 = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will inplace-merge &lt;coverage2&gt; into &lt;coverage1&gt;
 */
</span>    let dict1;
    let dict2;
    Object.keys(coverage2).forEach(function (file) {
        // if coverage1[file] is undefined, then override it
        if (!coverage1[file]) {
            coverage1[file] = coverage2[file];
            return;
        }
        // merge coverage2 into coverage1
        [
            &quot;b&quot;, &quot;f&quot;, &quot;s&quot;
        ].forEach(function (key) {
            dict1 = coverage1[file][key];
            dict2 = coverage2[file][key];
            switch (key) {
            // increment coverage for branch lines
            case &quot;b&quot;:
                Object.keys(dict2).forEach(function (key) {
                    dict2[key].forEach(function (cnt, ii) {
                        dict1[key][ii] += cnt;
                    });
                });
                break;
            // increment coverage for function and statement lines
            case &quot;f&quot;:
            case &quot;s&quot;:
                Object.keys(dict2).forEach(function (key) {
                    dict1[key] += dict2[key];
                });
                break;
            }
        });
    });
    return coverage1;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    });
/* jslint ignore:start */
// validate opt.coverage1
local.assertJsonEqual(opt.coverage1,
{&quot;/test&quot;:{&quot;b&quot;:{&quot;1&quot;:[0,1]},&quot;branchMap&quot;:{&quot;1&quot;:{&quot;line&quot;:2,&quot;locations
&quot;:[{&quot;end&quot;:{&quot;column&quot;:25,&quot;line&quot;:2},&quot;start&quot;:{&quot;column&quot;:13,&quot;line&quot;:2}},{&
quot;end&quot;:{&quot;column&quot;:40,&quot;line&quot;:2},&quot;start&quot;:{&quot;column&quot;:28,&quot;line&quot;:2}}],&quot;type
&quot;:&quot;cond-expr&quot;}},&quot;code&quot;:[&quot;(function () {&quot;,&quot;return arg ? __coverage__ : __coverage__;&quot
;,&quot;}());&quot;],&quot;f&quot;:{&quot;1&quot;:1},&quot;fnMap&quot;:{&quot;1&quot;:{&quot;line&quot;:1,&quot;loc&quot;:{&quot
;end&quot;:{&quot;column&quot;:13,&quot;line&quot;:1},&quot;start&quot;:{&quot;column&quot;:1,&quot;line&quot;:1}},&quot;name&quot
;:&quot;(anonymous_1)&quot;}},&quot;path&quot;:&quot;/test&quot;,&quot;s&quot;:{&quot;1&quot;:1,&quot;2&quot;:1},&quot;statementMap
&quot;:{&quot;1&quot;:{&quot;end&quot;:{&quot;column&quot;:5,&quot;line&quot;:3},&quot;start&quot;:{&quot;column&quot;:0,&quot;line
&quot;:1}},&quot;2&quot;:{&quot;end&quot;:{&quot;column&quot;:41,&quot;line&quot;:2},&quot;start&quot;:{&quot;column&quot;:0,&quot
;line&quot;:2}}}}}
);
// test merge-create handling-behavior
opt.coverage1 = local.istanbul.<span class="apidocCodeKeywordSpan">coverageMerge</span>({}, opt.coverage1);
// validate opt.coverage1
local.assertJsonEqual(opt.coverage1,
{&quot;/test&quot;:{&quot;b&quot;:{&quot;1&quot;:[0,1]},&quot;branchMap&quot;:{&quot;1&quot;:{&quot;line&quot;:2,&quot;locations
&quot;:[{&quot;end&quot;:{&quot;column&quot;:25,&quot;line&quot;:2},&quot;start&quot;:{&quot;column&quot;:13,&quot;line&quot;:2}},{&
quot;end&quot;:{&quot;column&quot;:40,&quot;line&quot;:2},&quot;start&quot;:{&quot;column&quot;:28,&quot;line&quot;:2}}],&quot;type
&quot;:&quot;cond-expr&quot;}},&quot;code&quot;:[&quot;(function () {&quot;,&quot;return arg ? __coverage__ : __coverage__;&quot
;,&quot;}());&quot;],&quot;f&quot;:{&quot;1&quot;:1},&quot;fnMap&quot;:{&quot;1&quot;:{&quot;line&quot;:1,&quot;loc&quot;:{&quot
;end&quot;:{&quot;column&quot;:13,&quot;line&quot;:1},&quot;start&quot;:{&quot;column&quot;:1,&quot;line&quot;:1}},&quot;name&quot
;:&quot;(anonymous_1)&quot;}},&quot;path&quot;:&quot;/test&quot;,&quot;s&quot;:{&quot;1&quot;:1,&quot;2&quot;:1},&quot;statementMap
&quot;:{&quot;1&quot;:{&quot;end&quot;:{&quot;column&quot;:5,&quot;line&quot;:3},&quot;start&quot;:{&quot;column&quot;:0,&quot;line
&quot;:1}},&quot;2&quot;:{&quot;end&quot;:{&quot;column&quot;:41,&quot;line&quot;:2},&quot;start&quot;:{&quot;column&quot;:0,&quot
;line&quot;:2}}}}}
);
// init opt.coverage2
opt.coverage2 = local.vm.runInNewContext(opt.data, { arg: 1 });
// validate opt.coverage2
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.coverageReportCreate" id="apidoc.elem.istanbul-lite.coverageReportCreate">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>coverageReportCreate
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coverageReportCreate = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will
    // 1. merge previous &lt;dirCoverage&gt;/coverage.json into &lt;opt&gt;.coverage
    // 2. convert &lt;opt&gt;.coverage to &lt;summaryDict&gt;
    // 3. convert &lt;summaryDict&gt; to &lt;nodeRoot&gt;
    // 4. convert &lt;nodeRoot&gt; to text-report &lt;dirCoverage&gt;/coverage.txt
    // 5. convert &lt;nodeRoot&gt; to html-report &lt;dirCoverage&gt;/\*
    // 6. return coverage-report in html-format as single document
 */
</span>    let coverageInclude;
    let dirCoverage;
    let filePrefix;
    let filesUnderRoot;
    let htmlAll;
    let nodeChildAdd;
    let nodeCreate;
    let nodeDict;
    let nodeNormalize;
    let nodeRoot;
    let summaryDict;
    let tmp;
    let tmpChildren;
    if (!(opt &amp;&amp; opt.coverage)) {
        return &quot;&quot;;
    }
    // init function
    nodeChildAdd = function (node, child) {
    /*
     * this function will add &lt;child&gt; to &lt;node&gt;
     */
        node.children.push(child);
        child.parent = node;
    };
    nodeCreate = function (pathname) {
    /*
     * this function will create a tree-node
     */
        return {
            children: [],
            pathname,
            metrics: {
                branches: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: &quot;Unknown&quot;
                },
                functions: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: &quot;Unknown&quot;
                },
                lines: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: &quot;Unknown&quot;
                },
                statements: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: &quot;Unknown&quot;
                }
            },
            name: pathname
        };
    };
    nodeNormalize = function (node, level, filePrefix, parent) {
    /*
     * this function will recursively normalize &lt;node&gt; and its children
     */
        let metric;
        // init name
        if (node.name.indexOf(filePrefix) === 0) {
            node.name = node.name.slice(filePrefix.length);
        }
        if (node.name[0] === path.sep) {
            node.name = node.name.slice(1);
        }
        // init relativeName
        node.relativeName = (
            parent
            ? (
                parent.name !== &quot;__root__/&quot;
                ? node.name.slice(parent.name.length)
                : node.name
            )
            : node.name.slice(filePrefix.length)
        );
        // init nameOrAllFiles
        node.nameOrAllFiles = node.name || &quot;All files&quot;;
        // init relativeNameOrAllFiles
        node.relativeNameOrAllFiles = node.relativeName || &quot;All files&quot;;
        // init href
        node.href = node.relativeName.split(path.sep).join(&quot;/&quot;) + (
            node.isFile
            ? &quot;.html&quot;
            : &quot;index.html&quot;
        );
        // recurse
        node.children.forEach(function (child) {
            nodeNormalize(child, level + 1, filePrefix, node);
        });
        // sort children by name
        node.children.sort(function (aa, bb) {
            return (
                aa.name &gt; bb.name
                ? 1
                : -1
            );
        });
        // init metrics
        if (!node.isFile) {
            node.children.forEach(function (child) {
                [
                    &quot;lines&quot;, &quot;statements&quot;, &quot;branches&quot;, &quot;functions&quot;
                ].forEach(function (key) {
                    metric = node.metrics[key];
                    metric.total += child.metrics[key].total;
                    metric.covered += child.metrics[key].covered;
                    metric.skipped += child.metrics[key].skipped;...</pre></li>
    <li>example use<pre class="apidocCodePre">...
            &quot;/inputTextarea1.js&quot;\n\
        );\n\
        eval( // jslint ignore:line\n\
            document.querySelector(&quot;#outputTextarea1&quot;).value\n\
        );\n\
        document.querySelector(\n\
            &quot;#htmlCoverageReport1&quot;\n\
        ).innerHTML = local.istanbul.<span class="apidocCodeKeywordSpan">coverageReportCreate</span>({\n\
            coverage: globalThis.__coverage__\n\
        });\n\
    } catch (errCaught) {\n\
        console.error(errCaught);\n\
    }\n\
    break;\n\
}\n\
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser" id="apidoc.elem.istanbul-lite.esprima.Parser">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>esprima.Parser
        <span class="apidocSignatureSpan">(options, input, startPos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords[options.ecmaVersion &gt;= 6 ? 6 : options.sourceType === &quot;module&quot; ? &quot;5module&quot; : 5]);
  var reserved = &quot;&quot;;
  if (options.allowReserved !== true) {
    for (var v = options.ecmaVersion;; v--)
      { if (reserved = reservedWords[v]) { break } }
    if (options.sourceType === &quot;module&quot;) { reserved += &quot; await&quot;; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + &quot; &quot; : &quot;&quot;) + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + &quot; &quot; + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf(&quot;\n&quot;, startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it&apos;s a module code.
  this.inModule = options.sourceType === &quot;module&quot;;
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = {};

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 &amp;&amp; options.allowHashBang &amp;&amp; this.input.slice(0, 2) === &quot;#!&quot;)
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Position" id="apidoc.elem.istanbul-lite.esprima.Position">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>esprima.Position
        <span class="apidocSignatureSpan">(line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Position(line, col) {
  this.line = line;
  this.column = col;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.Controller" id="apidoc.elem.istanbul-lite.estraverse.Controller">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>estraverse.Controller
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Controller() { }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.fsReadFileOrDefaultSync" id="apidoc.elem.istanbul-lite.fsReadFileOrDefaultSync">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>fsReadFileOrDefaultSync
        <span class="apidocSignatureSpan">(pathname, type, dflt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsReadFileOrDefaultSync = function (pathname, type, dflt) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync-read &lt;pathname&gt; with given &lt;type&gt; and &lt;dflt&gt;
 */
</span>    let fs;
    // do nothing if module does not exist
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return dflt;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to read pathname
    try {
        return (
            type === &quot;json&quot;
            ? JSON.parse(fs.readFileSync(pathname, &quot;utf8&quot;))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.fsRmrfSync" id="apidoc.elem.istanbul-lite.fsRmrfSync">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>fsRmrfSync
        <span class="apidocSignatureSpan">(pathname)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsRmrfSync = function (pathname) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync &quot;rm -rf&quot; &lt;pathname&gt;
 */
</span>    let child_process;
    // do nothing if module does not exist
    try {
        child_process = require(&quot;child_process&quot;);
    } catch (ignore) {
        return;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    if (process.platform !== &quot;win32&quot;) {
        child_process.spawnSync(&quot;rm&quot;, [
            &quot;-rf&quot;, pathname
        ], {
            stdio: [
                &quot;ignore&quot;, 1, 2
            ]
        });
        return;
    }
    try {
        child_process.spawnSync(&quot;rd&quot;, [
            &quot;/s&quot;, &quot;/q&quot;, pathname
        ], {
            stdio: [
                &quot;ignore&quot;, 1, &quot;ignore&quot;
            ]
        });
    } catch (ignore) {}
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        local.env, {
            npm_config_mode_coverage_merge: &quot;1&quot;
        }
    ]
], function (onError) {
    // cleanup old coverage
    if (!local.isBrowser) {
        local.<span class="apidocCodeKeywordSpan">fsRmrfSync</span>(&quot;tmp/build/coverage.html/aa&quot;);
    }
    // test path handling-behavior
    [
        &quot;/&quot;, local.__dirname
    ].forEach(function (dir) {
        [
            &quot;zz.js&quot;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.fsWriteFileWithMkdirpSync" id="apidoc.elem.istanbul-lite.fsWriteFileWithMkdirpSync">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>fsWriteFileWithMkdirpSync
        <span class="apidocSignatureSpan">(pathname, data, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsWriteFileWithMkdirpSync = function (pathname, data, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync write &lt;data&gt; to &lt;pathname&gt; with &quot;mkdir -p&quot;
 */
</span>    let fs;
    let success;
    // do nothing if module does not exist
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to write pathname
    try {
        fs.writeFileSync(pathname, data);
        success = true;
    } catch (ignore) {
        // mkdir -p
        fs.mkdirSync(require(&quot;path&quot;).dirname(pathname), {
            recursive: true
        });
        // re-write pathname
        fs.writeFileSync(pathname, data);
        success = true;
    }
    if (success &amp;&amp; msg) {
        console.error(msg.replace(&quot;{{pathname}}&quot;, pathname));
    }
    return success;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.identity" id="apidoc.elem.istanbul-lite.identity">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>identity
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;val&gt;
 */
</span>    return val;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
local.cliDict.help = local.cliDict.help || local.cliDict._help;
local.cliDict._interactive = local.cliDict._interactive || function () {
/*
 *
 * will start interactive-mode
 */
    globalThis.local = local;
    local.<span class="apidocCodeKeywordSpan">identity</span>(local.replStart || require(&quot;repl&quot;).start)({
        useGlobal: true
    });
};
local.cliDict[&quot;--interactive&quot;] = (
    local.cliDict[&quot;--interactive&quot;]
    || local.cliDict._interactive
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.instrumentInPackage" id="apidoc.elem.istanbul-lite.instrumentInPackage">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>instrumentInPackage
        <span class="apidocSignatureSpan">(code, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrumentInPackage = function (code, file) {
<span class="apidocCodeCommentSpan">/*
 * this function will instrument &lt;code&gt;
 * if macro /\* istanbul instrument in package $npm_package_nameLib *\/
 * exists in &lt;code&gt;
 */
</span>    return (
        (
            process.env.npm_config_mode_coverage
            &amp;&amp; code.indexOf(&quot;/* istanbul ignore all */\n&quot;) &lt; 0 &amp;&amp; (
                process.env.npm_config_mode_coverage === &quot;all&quot;
                || process.env.npm_config_mode_coverage === &quot;node_modules&quot;
                || code.indexOf(
                    &quot;/* istanbul instrument in package &quot;
                    + process.env.npm_package_nameLib + &quot; */\n&quot;
                ) &gt;= 0
                || code.indexOf(
                    &quot;/* istanbul instrument in package &quot;
                    + process.env.npm_config_mode_coverage + &quot; */\n&quot;
                ) &gt;= 0
            )
        )
        ? local.instrumentSync(code, file)
        : code
    );
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.instrumentSync" id="apidoc.elem.istanbul-lite.instrumentSync">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>instrumentSync
        <span class="apidocSignatureSpan">(code, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrumentSync = function (code, file) {
<span class="apidocCodeCommentSpan">/*
 * this function will
    // 1. normalize &lt;file&gt;
    // 2. save &lt;code&gt; to __coverageInclude__[&lt;file&gt;] for future html-report
    // 3. return instrumented-code
 */
</span>    // 1. normalize &lt;file&gt;
    file = path.resolve(file);
    // 2. save &lt;code&gt; to __coverageInclude__[&lt;file&gt;] for future html-report
    globalThis.__coverageInclude__[file] = 1;
    // 3. return instrumented-code
    return new local.Instrumenter({
        embedSource: true,
        esModules: true,
        noAutoWrap: true
    }).instrumentSync(code, file).trimStart();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
try {\n\
    delete globalThis.__coverage__[&quot;/inputTextarea1.js&quot;];\n\
} catch (ignore) {}\n\
// try to cover and eval #inputTextarea1\n\
try {\n\
    document.querySelector(\n\
        &quot;#outputTextarea1&quot;\n\
    ).textContent = local.istanbul.<span class="apidocCodeKeywordSpan">instrumentSync</span>(\n\
        document.querySelector(&quot;#inputTextarea1&quot;).value,\n\
        &quot;/inputTextarea1.js&quot;\n\
    );\n\
    eval( // jslint ignore:line\n\
        document.querySelector(&quot;#outputTextarea1&quot;).value\n\
    );\n\
    document.querySelector(\n\
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.nop" id="apidoc.elem.istanbul-lite.nop">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>nop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nop = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...


// run shared js-env code - function
(function () {
let process;
let require;
// hack-jslint
local.<span class="apidocCodeKeywordSpan">nop</span>(require);
globalThis.__coverageInclude__ = local.coalesce(
globalThis.__coverageInclude__,
{}
);
// mock builtins
process = local.process || {
cwd: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.objectAssignDefault" id="apidoc.elem.istanbul-lite.objectAssignDefault">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>objectAssignDefault
        <span class="apidocSignatureSpan">(tgt = {}, src = {}, depth = 0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectAssignDefault = function (tgt = {}, src = {}, depth = 0) {
<span class="apidocCodeCommentSpan">/*
 * this function will if items from &lt;tgt&gt; are null, undefined, or &quot;&quot;,
 * then overwrite them with items from &lt;src&gt;
 */
</span>    let recurse;
    recurse = function (tgt, src, depth) {
        Object.entries(src).forEach(function ([
            key, bb
        ]) {
            let aa;
            aa = tgt[key];
            if (aa === undefined || aa === null || aa === &quot;&quot;) {
                tgt[key] = bb;
                return;
            }
            if (
                depth !== 0
                &amp;&amp; typeof aa === &quot;object&quot; &amp;&amp; aa &amp;&amp; !Array.isArray(aa)
                &amp;&amp; typeof bb === &quot;object&quot; &amp;&amp; bb &amp;&amp; !Array.isArray(bb)
            ) {
                recurse(aa, bb, depth - 1);
            }
        });
    };
    recurse(tgt, src, depth | 0);
    return tgt;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        }).join(&quot; &quot;).replace((
            /\u001b\[\d*m/g
        ), &quot;&quot;) + &quot;\n&quot;;
        // scroll textarea to bottom
        elem.scrollTop = elem.scrollHeight;
    };
});
local.<span class="apidocCodeKeywordSpan">objectAssignDefault</span>(local, globalThis.domOnEventDelegateDict);
globalThis.domOnEventDelegateDict = local;
}());



// run node js-env code - init-test
/* istanbul ignore next */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.hrtime" id="apidoc.elem.istanbul-lite.process.hrtime">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>process.hrtime
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hrtime(time) {
  _hrtime(hrValues);

  if (time !== undefined) {
    if (!ArrayIsArray(time)) {
      throw new ERR_INVALID_ARG_TYPE(&apos;time&apos;, &apos;Array&apos;, time);
    }
    if (time.length !== 2) {
      throw new ERR_OUT_OF_RANGE(&apos;time&apos;, 2, time.length);
    }

    const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];
    const nsec = hrValues[2] - time[1];
    const needsBorrow = nsec &lt; 0;
    return [needsBorrow ? sec - 1 : sec, needsBorrow ? nsec + 1e9 : nsec];
  }

  return [
    hrValues[0] * 0x100000000 + hrValues[1],
    hrValues[2]
  ];
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.require" id="apidoc.elem.istanbul-lite.require">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>require
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function require(path) {
  return mod.require(path);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
cwd: function () {
    return &quot;&quot;;
},
env: {}
};
require = function (key) {
try {
    return local[&quot;__istanbul_&quot; + key] || local[key] || local.<span class="apidocCodeKeywordSpan">require</span>(key);
} catch (ignore) {}
};
local[&quot;./package.json&quot;] = {};
// mock module path
local.__istanbul_path = local.path || {
dirname: function (file) {
    return file.replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.require.resolve" id="apidoc.elem.istanbul-lite.require.resolve">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>require.resolve
        <span class="apidocSignatureSpan">(request, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve(request, options) {
  validateString(request, &apos;request&apos;);
  return Module._resolveFilename(request, mod, false, options);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.templateRender" id="apidoc.elem.istanbul-lite.templateRender">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>templateRender
        <span class="apidocSignatureSpan">(template, dict, opt, ii)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateRender = function (template, dict, opt, ii) {
<span class="apidocCodeCommentSpan">/*
 * this function will render &lt;template&gt; with given &lt;dict&gt;
 */
</span>    let argList;
    let getVal;
    let match;
    let renderPartial;
    let rgx;
    let skip;
    let val;
    if (dict === null || dict === undefined) {
        dict = {};
    }
    opt = opt || {};
    getVal = function (key) {
        argList = key.split(&quot; &quot;);
        val = dict;
        if (argList[0] === &quot;#this/&quot;) {
            return val;
        }
        if (argList[0] === &quot;#ii/&quot;) {
            return ii;
        }
        // iteratively lookup nested val in dict
        argList[0].split(&quot;.&quot;).forEach(function (key) {
            val = val &amp;&amp; val[key];
        });
        return val;
    };
    renderPartial = function (match0, helper, key, partial) {
        switch (helper) {
        case &quot;each&quot;:
        case &quot;eachTrimEndComma&quot;:
            val = getVal(key);
            val = (
                Array.isArray(val)
                ? val.map(function (dict, ii) {
                    // recurse with partial
                    return local.templateRender(partial, dict, opt, ii);
                }).join(&quot;&quot;)
                : &quot;&quot;
            );
            // remove trailing-comma from last elem
            if (helper === &quot;eachTrimEndComma&quot;) {
                val = val.trimEnd().replace((
                    /,$/
                ), &quot;&quot;);
            }
            return val;
        case &quot;if&quot;:
            partial = partial.split(&quot;{{#unless &quot; + key + &quot;}}&quot;);
            partial = (
                getVal(key)
                ? partial[0]
                // handle &quot;unless&quot; case
                : partial.slice(1).join(&quot;{{#unless &quot; + key + &quot;}}&quot;)
            );
            // recurse with partial
            return local.templateRender(partial, dict, opt);
        case &quot;unless&quot;:
            return (
                getVal(key)
                ? &quot;&quot;
                // recurse with partial
                : local.templateRender(partial, dict, opt)
            );
        default:
            // recurse with partial
            return match0[0] + local.templateRender(match0.slice(1), dict, opt);
        }
    };
    // render partials
    rgx = (
        /\{\{#(\w+)\u0020([^}]+?)\}\}/g
    );
    template = template || &quot;&quot;;
    match = rgx.exec(template);
    while (match) {
        rgx.lastIndex += 1 - match[0].length;
        template = template.replace(
            new RegExp(
                &quot;\\{\\{#(&quot; + match[1] + &quot;) (&quot; + match[2]
                + &quot;)\\}\\}([\\S\\s]*?)\\{\\{/&quot; + match[1] + &quot; &quot; + match[2]
                + &quot;\\}\\}&quot;
            ),
            renderPartial
        );
        match = rgx.exec(template);
    }
    // search for keys in template
    return template.replace((
        /\{\{[^}]+?\}\}/g
    ), function (match0) {
        let markdownToHtml;
        let notHtmlSafe;
        notHtmlSafe = opt.notHtmlSafe;
        try {
            val = getVal(match0.slice(2, -2));
            if (val === undefined) {
                return match0;
            }
            argList.slice(1).forEach(function (fmt, ii, list) {
                switch (fmt) {
                case &quot;*&quot;:
                case &quot;+&quot;:
                case &quot;-&quot;:
                case &quot;/&quot;:
                    skip = ii + 1;
                    val = String(
                        fmt === &quot;*&quot;
                        ? Number(val) * Number(list[skip])
                        : fmt === &quot;+&quot;
                        ? Number(val) + Number(list[skip])
                        : fmt === &quot;-&quot;
                        ? Number(val) - Number(list[skip])
                        : Number(val) / Number(list[skip])
                    );
                    break;...</pre></li>
    <li>example use<pre class="apidocCodePre">...
case &quot;each&quot;:
case &quot;eachTrimEndComma&quot;:
    val = getVal(key);
    val = (
        Array.isArray(val)
        ? val.map(function (dict, ii) {
            // recurse with partial
            return local.<span class="apidocCodeKeywordSpan">templateRender</span>(partial, dict, opt, ii);
        }).join(&quot;&quot;)
        : &quot;&quot;
    );
    // remove trailing-comma from last elem
    if (helper === &quot;eachTrimEndComma&quot;) {
        val = val.trimEnd().replace((
            /,$/
...</pre></li>
    </ul>












































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.Instrumenter" id="apidoc.module.istanbul-lite.Instrumenter">module istanbul-lite.Instrumenter</a></h1>


    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.Instrumenter" id="apidoc.elem.istanbul-lite.Instrumenter.Instrumenter">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>Instrumenter
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Instrumenter(options) {
    this.opts = options || {
        debug: false,
        walkDebug: false,
        coverageVariable: &apos;__coverage__&apos;,
        codeGenerationOptions: undefined,
        noAutoWrap: false,
        noCompact: false,
        embedSource: false,
        preserveComments: false,
        esModules: false
    };

    if (this.opts.esModules &amp;&amp; !this.opts.noAutoWrap) {
        this.opts.noAutoWrap = true;
        if (this.opts.debug) {
            console.log(&apos;Setting noAutoWrap to true as required by esModules&apos;);
        }
    }

    this.walker = new Walker({
        ArrowFunctionExpression: [ this.arrowBlockConverter ],
        ExpressionStatement: this.coverStatement,
        ExportNamedDeclaration: this.coverExport,
        BreakStatement: this.coverStatement,
        ContinueStatement: this.coverStatement,
        DebuggerStatement: this.coverStatement,
        ReturnStatement: this.coverStatement,
        ThrowStatement: this.coverStatement,
        TryStatement: [ this.paranoidHandlerCheck, this.coverStatement],
        VariableDeclaration: this.coverStatement,
        IfStatement: [ this.ifBlockConverter, this.coverStatement, this.ifBranchInjector ],
        ForStatement: [ this.skipInit, this.loopBlockConverter, this.coverStatement ],
        ForInStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
        ForOfStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
        WhileStatement: [ this.loopBlockConverter, this.coverStatement ],
        DoWhileStatement: [ this.loopBlockConverter, this.coverStatement ],
        SwitchStatement: [ this.coverStatement, this.switchBranchInjector ],
        SwitchCase: [ this.switchCaseInjector ],
        WithStatement: [ this.withBlockConverter, this.coverStatement ],
        FunctionDeclaration: [ this.coverFunction, this.coverStatement ],
        FunctionExpression: this.coverFunction,
        LabeledStatement: this.coverStatement,
        ConditionalExpression: this.conditionalBranchInjector,
        LogicalExpression: this.logicalExpressionBranchInjector,
        ObjectExpression: this.maybeAddType,
        MetaProperty: this.coverMetaProperty,
    }, this.extractCurrentHint, this, this.opts.walkDebug);

    //unit testing purposes only
    if (this.opts.backdoor &amp;&amp; this.opts.backdoor.omitTrackerSuffix) {
        this.omitTrackerSuffix = true;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.Instrumenter.prototype" id="apidoc.module.istanbul-lite.Instrumenter.prototype">module istanbul-lite.Instrumenter.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.arrowBlockConverter" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.arrowBlockConverter">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>arrowBlockConverter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrowBlockConverter = function (node) {
    var retStatement;
    if (node.expression) { // turn expression nodes into a block with a return statement
        retStatement = astgen.returnStatement(node.body);
        // ensure the generated return statement is covered
        retStatement.loc = node.body.loc;
        node.body = this.convertToBlock(retStatement);
        node.expression = false;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.branchIncrementExprAst" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.branchIncrementExprAst">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>branchIncrementExprAst
        <span class="apidocSignatureSpan">(varName, branchIndex, down)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">branchIncrementExprAst = function (varName, branchIndex, down) {
    var ret = astgen.postIncrement(
        astgen.subscript(
            astgen.subscript(
                astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&apos;b&apos;)),
                astgen.stringLiteral(varName)
            ),
            astgen.numericLiteral(branchIndex)
        ),
        down
    );
    return ret;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.branchLocationFor" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.branchLocationFor">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>branchLocationFor
        <span class="apidocSignatureSpan">(name, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">branchLocationFor = function (name, index) {
    return this.coverState.branchMap[name].locations[index];
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.branchName" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.branchName">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>branchName
        <span class="apidocSignatureSpan">(type, startLine, pathLocations)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">branchName = function (type, startLine, pathLocations) {
    var bName,
        paths = [],
        locations = [],
        i,
        ignoring = !!this.currentState.ignoring;
    this.currentState.branch += 1;
    bName = this.currentState.branch;
    for (i = 0; i &lt; pathLocations.length; i += 1) {
        pathLocations[i].skip = pathLocations[i].skip || ignoring || undefined;
        locations.push(pathLocations[i]);
        paths.push(0);
    }
    this.coverState.b[bName] = paths;
    this.coverState.branchMap[bName] = { line: startLine, type: type, locations: locations };
    return bName;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.conditionalBranchInjector" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.conditionalBranchInjector">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>conditionalBranchInjector
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conditionalBranchInjector = function (node, walker) {
    var bName = this.branchName(&apos;cond-expr&apos;, walker.startLineForNode(node), this.locationsForNodes([ node.consequent, node.alternate
 ])),
        ast1 = this.branchIncrementExprAst(bName, 0),
        ast2 = this.branchIncrementExprAst(bName, 1);

    node.consequent.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, 0));
    node.alternate.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, 1));
    node.consequent = astgen.sequence(ast1, node.consequent);
    node.alternate = astgen.sequence(ast2, node.alternate);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.convertToBlock" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.convertToBlock">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>convertToBlock
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">convertToBlock = function (node) {
    if (!node) {
        return { type: &apos;BlockStatement&apos;, body: [] };
    } else if (node.type === &apos;BlockStatement&apos;) {
        return node;
    } else {
        return { type: &apos;BlockStatement&apos;, body: [ node ] };
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.coverExport" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.coverExport">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>coverExport
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coverExport = function (node, walker) {
    var sName, incrStatementCount;

    if ( !node.declaration || !node.declaration.declarations ) { return; }

    this.maybeSkipNode(node, &apos;next&apos;);

    sName = this.statementName(node.declaration.loc);
    incrStatementCount = astgen.statement(
        astgen.postIncrement(
            astgen.subscript(
                astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&apos;s&apos;)),
                astgen.stringLiteral(sName)
            )
        )
    );

    this.splice(incrStatementCount, node, walker);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.coverFunction" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.coverFunction">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>coverFunction
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coverFunction = function (node, walker) {
    var id,
        body = node.body,
        blockBody = body.body,
        popped;

    this.maybeSkipNode(node, &apos;next&apos;);

    id = this.functionName(node, walker.startLineForNode(node), {
        start: node.loc.start,
        end: { line: node.body.loc.start.line, column: node.body.loc.start.column }
    });

    if (blockBody.length &gt; 0 &amp;&amp; this.isUseStrictExpression(blockBody[0])) {
        popped = blockBody.shift();
    }
    blockBody.unshift(
        astgen.statement(
            astgen.postIncrement(
                astgen.subscript(
                    astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&apos;f&apos;)),
                    astgen.stringLiteral(id)
                )
            )
        )
    );
    if (popped) {
        blockBody.unshift(popped);
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.coverMetaProperty" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.coverMetaProperty">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>coverMetaProperty
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
   node.skipSelf = true;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.coverStatement" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.coverStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>coverStatement
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coverStatement = function (node, walker) {
    var sName,
        incrStatementCount,
        parent,
        grandParent;

    this.maybeSkipNode(node, &apos;next&apos;);

    if (this.isUseStrictExpression(node)) {
        grandParent = walker.ancestor(2);
<span class="apidocCodeCommentSpan">        /* istanbul ignore else: difficult to test */
</span>        if (grandParent) {
            if ((grandParent.node.type === SYNTAX.FunctionExpression.name ||
                grandParent.node.type === SYNTAX.FunctionDeclaration.name)  &amp;&amp;
                walker.parent().node.body[0] === node) {
                return;
            }
        }
    }

    if (node.type === SYNTAX.FunctionDeclaration.name) {
        // Called for the side-effect of setting the function&apos;s statement count to 1.
        this.statementName(node.loc, 1);
    } else {
        // We let `coverExport` handle ExportNamedDeclarations.
        parent = walker.parent();
        if (parent &amp;&amp; parent.node.type === SYNTAX.ExportNamedDeclaration.name) {
            return;
        }

        sName = this.statementName(node.loc);

        incrStatementCount = astgen.statement(
            astgen.postIncrement(
                astgen.subscript(
                    astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&apos;s&apos;)),
                    astgen.stringLiteral(sName)
                )
            )
        );

        this.splice(incrStatementCount, node, walker);
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.endIgnore" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.endIgnore">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>endIgnore
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endIgnore = function () {
    this.currentState.ignoring -= 1;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.extractCurrentHint" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.extractCurrentHint">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>extractCurrentHint
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractCurrentHint = function (node) {
    if (!node.range) { return; }
    var i = this.currentState.lastHintPosition + 1,
        hints = this.currentState.hints,
        nodeStart = node.range[0],
        hint;
    this.currentState.currentHint = null;
    // hack-coverage - allow top-level istanbul-ignore-next
    if (node.type === &quot;Program&quot;) { return; }
    while (i &lt; hints.length) {
        hint = hints[i];
        if (hint.end &lt; nodeStart) {
            this.currentState.currentHint = hint;
            this.currentState.lastHintPosition = i;
            i += 1;
        } else {
            break;
        }
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.filterHints" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.filterHints">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>filterHints
        <span class="apidocSignatureSpan">(comments)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterHints = function (comments) {
    var ret = [],
        i,
        comment,
        groups;
    if (!(comments &amp;&amp; isArray(comments))) {
        return ret;
    }
    for (i = 0; i &lt; comments.length; i += 1) {
        comment = comments[i];
<span class="apidocCodeCommentSpan">        /* istanbul ignore else: paranoid check */
</span>        if (comment &amp;&amp; comment.value &amp;&amp; comment.range &amp;&amp; isArray(comment.range)) {
            groups = String(comment.value).match(COMMENT_RE);
            if (groups) {
                ret.push({ type: groups[1], start: comment.range[0], end: comment.range[1] });
            }
        }
    }
    return ret;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.findLeaves" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.findLeaves">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>findLeaves
        <span class="apidocSignatureSpan">(node, accumulator, parent, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLeaves = function (node, accumulator, parent, property) {
    if (node.type === SYNTAX.LogicalExpression.name) {
        this.findLeaves(node.left, accumulator, node, &apos;left&apos;);
        this.findLeaves(node.right, accumulator, node, &apos;right&apos;);
    } else {
        accumulator.push({ node: node, parent: parent, property: property });
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.fixColumnPositions" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.fixColumnPositions">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>fixColumnPositions
        <span class="apidocSignatureSpan">(coverState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fixColumnPositions = function (coverState) {
    var offset = LEADER_WRAP.length,
        fixer = function (loc) {
            if (loc.start.line === 1) {
                loc.start.column -= offset;
            }
            if (loc.end.line === 1) {
                loc.end.column -= offset;
            }
        },
        k,
        obj,
        i,
        locations;

    obj = coverState.statementMap;
    for (k in obj) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else: has own property */
</span>        if (obj.hasOwnProperty(k)) { fixer(obj[k]); }
    }
    obj = coverState.fnMap;
    for (k in obj) {
        /* istanbul ignore else: has own property */
        if (obj.hasOwnProperty(k)) { fixer(obj[k].loc); }
    }
    obj = coverState.branchMap;
    for (k in obj) {
        /* istanbul ignore else: has own property */
        if (obj.hasOwnProperty(k)) {
            locations = obj[k].locations;
            for (i = 0; i &lt; locations.length; i += 1) {
                fixer(locations[i]);
            }
        }
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.functionName" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.functionName">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>functionName
        <span class="apidocSignatureSpan">(node, line, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionName = function (node, line, location) {
    this.currentState.func += 1;
    var id = this.currentState.func,
        ignoring = !!this.currentState.ignoring,
        name = node.id ? node.id.name : &apos;(anonymous_&apos; + id + &apos;)&apos;,
        clone = function (attr) {
            var obj = location[attr] || /* istanbul ignore next */ {};
            return { line: obj.line, column: obj.column };
        };
    this.coverState.fnMap[id] = {
        name: name, line: line,
        loc: {
            start: clone(&apos;start&apos;),
            end: clone(&apos;end&apos;)
        },
        skip: ignoring || undefined
    };
    this.coverState.f[id] = 0;
    return id;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.getPreamble" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.getPreamble">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>getPreamble
        <span class="apidocSignatureSpan">(sourceCode, emitUseStrict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPreamble = function (sourceCode, emitUseStrict) {
    var varName = this.opts.coverageVariable || &apos;__coverage__&apos;,
        file = this.coverState.path.replace(/\\/g, &apos;\\\\&apos;),
        tracker = this.currentState.trackerVar,
        coverState,
        strictLine = emitUseStrict ? &apos;&quot;use strict&quot;;&apos; : &apos;&apos;,
        // return replacements using the function to ensure that the replacement is
        // treated like a dumb string and not as a string with RE replacement patterns
        replacer = function (s) {
            return function () { return s; };
        },
        code;
    if (!this.opts.noAutoWrap) {
        this.fixColumnPositions(this.coverState);
    }
    if (this.opts.embedSource) {
        this.coverState.code = sourceCode.split(/(?:\r?\n)|\r/);
    }
    coverState = this.opts.debug ? JSON.stringify(this.coverState, undefined, 4) : JSON.stringify(this.coverState);
    code = [
        &quot;%STRICT%&quot;,
        &quot;var %VAR% = (Function(&apos;return this&apos;))();&quot;,
        &quot;if (!%VAR%.%GLOBAL%) { %VAR%.%GLOBAL% = {}; }&quot;,
        &quot;%VAR% = %VAR%.%GLOBAL%;&quot;,
        &quot;if (!(%VAR%[&apos;%FILE%&apos;])) {&quot;,
        &quot;   %VAR%[&apos;%FILE%&apos;] = %OBJECT%;&quot;,
        &quot;}&quot;,
        &quot;%VAR% = %VAR%[&apos;%FILE%&apos;];&quot;
    ].join(&quot;\n&quot;)
        .replace(/%STRICT%/g, replacer(strictLine))
        .replace(/%VAR%/g, replacer(tracker))
        .replace(/%GLOBAL%/g, replacer(varName))
        .replace(/%FILE%/g, replacer(file))
        .replace(/%OBJECT%/g, replacer(coverState));
    return code;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.ifBlockConverter" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.ifBlockConverter">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>ifBlockConverter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ifBlockConverter = function (node) {
    node.consequent = this.convertToBlock(node.consequent);
    node.alternate = this.convertToBlock(node.alternate);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.ifBranchInjector" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.ifBranchInjector">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>ifBranchInjector
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ifBranchInjector = function (node, walker) {
    var alreadyIgnoring = !!this.currentState.ignoring,
        hint = this.currentState.currentHint,
        ignoreThen = !alreadyIgnoring &amp;&amp; hint &amp;&amp; hint.type === &apos;if&apos;,
        ignoreElse = !alreadyIgnoring &amp;&amp; hint &amp;&amp; hint.type === &apos;else&apos;,
        line = node.loc.start.line,
        col = node.loc.start.column,
        makeLoc = function () { return  { line: line, column: col }; },
        bName = this.branchName(&apos;if&apos;, walker.startLineForNode(node), [
            { start: makeLoc(), end: makeLoc(), skip: ignoreThen || undefined },
            { start: makeLoc(), end: makeLoc(), skip: ignoreElse || undefined }
        ]),
        thenBody = node.consequent.body,
        elseBody = node.alternate.body,
        child;
    thenBody.unshift(astgen.statement(this.branchIncrementExprAst(bName, 0)));
    elseBody.unshift(astgen.statement(this.branchIncrementExprAst(bName, 1)));
    if (ignoreThen) { child = node.consequent; child.preprocessor = this.startIgnore; child.postprocessor = this.endIgnore; }
    if (ignoreElse) { child = node.alternate; child.preprocessor = this.startIgnore; child.postprocessor = this.endIgnore; }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.instrument" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.instrument">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>instrument
        <span class="apidocSignatureSpan">(code, filename, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrument = function (code, filename, callback) {

    if (!callback &amp;&amp; typeof filename === &apos;function&apos;) {
        callback = filename;
        filename = null;
    }
    try {
        callback(null, this.instrumentSync(code, filename));
    } catch (ex) {
        callback(ex);
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.instrumentASTSync" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.instrumentASTSync">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>instrumentASTSync
        <span class="apidocSignatureSpan">(program, filename, originalCode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrumentASTSync = function (program, filename, originalCode) {
    var usingStrict = false,
        codegenOptions,
        generated,
        preamble,
        lineCount,
        i;
    filename = filename || String(new Date().getTime()) + &apos;.js&apos;;
    this.sourceMap = null;
    this.coverState = {
        path: filename,
        s: {},
        b: {},
        f: {},
        fnMap: {},
        statementMap: {},
        branchMap: {}
    };
    this.currentState = {
        trackerVar: generateTrackerVar(filename, this.omitTrackerSuffix),
        func: 0,
        branch: 0,
        variable: 0,
        statement: 0,
        hints: this.filterHints(program.comments),
        currentHint: null,
        lastHintPosition: -1,
        ignoring: 0
    };
    if (program.body &amp;&amp; program.body.length &gt; 0 &amp;&amp; this.isUseStrictExpression(program.body[0])) {
        //nuke it
        program.body.shift();
        //and add it back at code generation time
        usingStrict = true;
    }
    this.walker.startWalk(program);
    codegenOptions = this.opts.codeGenerationOptions || { format: { compact: !this.opts.noCompact }};
    codegenOptions.comment = this.opts.preserveComments;
    //console.log(JSON.stringify(program, undefined, 2));

    generated = ESPGEN.generate(program, codegenOptions);
    preamble = this.getPreamble(originalCode || &apos;&apos;, usingStrict);

    if (generated.map &amp;&amp; generated.code) {
        lineCount = preamble.split(/\r\n|\r|\n/).length;
        // offset all the generated line numbers by the number of lines in the preamble
        for (i = 0; i &lt; generated.map._mappings._array.length; i += 1) {
            generated.map._mappings._array[i].generatedLine += lineCount;
        }
        this.sourceMap = generated.map;
        generated = generated.code;
    }

    return preamble + &apos;\n&apos; + generated + &apos;\n&apos;;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.instrumentSync" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.instrumentSync">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>instrumentSync
        <span class="apidocSignatureSpan">(code, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrumentSync = function (code, filename) {
    var program;

    //protect from users accidentally passing in a Buffer object instead
    if (typeof code !== &apos;string&apos;) { throw new Error(&apos;Code must be string&apos;); }
    if (code.charAt(0) === &apos;#&apos;) { //shebang, &apos;comment&apos; it out, won&apos;t affect syntax tree locations for things we care about
        code = &apos;//&apos; + code;
    }
    if (!this.opts.noAutoWrap) {
        code = LEADER_WRAP + code + TRAILER_WRAP;
    }
    try {
        // hack-coverage - acorn opt
        let opt = {
            locations: true,
            onComment: [],
            onToken: this.opts.preserveComments,
            ranges: true,
            sourceType: this.opts.esModules ? &apos;module&apos; : &apos;script&apos;
        };
        program = ESP.parse(code, opt);
        program.comments = opt.onComment
    } catch (e) {
        console.log(&apos;Failed to parse file: &apos; + filename);
        throw e;
    }
    if (this.opts.preserveComments) {
        program = ESPGEN.attachComments(program, program.comments, program.tokens);
    }
    if (!this.opts.noAutoWrap) {
        program = {
            type: SYNTAX.Program.name,
            body: program.body[0].expression.callee.body.body,
            comments: program.comments
        };
    }
    return this.instrumentASTSync(program, filename, code);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
try {\n\
    delete globalThis.__coverage__[&quot;/inputTextarea1.js&quot;];\n\
} catch (ignore) {}\n\
// try to cover and eval #inputTextarea1\n\
try {\n\
    document.querySelector(\n\
        &quot;#outputTextarea1&quot;\n\
    ).textContent = local.istanbul.<span class="apidocCodeKeywordSpan">instrumentSync</span>(\n\
        document.querySelector(&quot;#inputTextarea1&quot;).value,\n\
        &quot;/inputTextarea1.js&quot;\n\
    );\n\
    eval( // jslint ignore:line\n\
        document.querySelector(&quot;#outputTextarea1&quot;).value\n\
    );\n\
    document.querySelector(\n\
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.isUseStrictExpression" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.isUseStrictExpression">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>isUseStrictExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isUseStrictExpression = function (node) {
    return node &amp;&amp; node.type === SYNTAX.ExpressionStatement.name &amp;&amp;
        node.expression  &amp;&amp; node.expression.type === SYNTAX.Literal.name &amp;&amp;
        node.expression.value === &apos;use strict&apos;;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.lastFileCoverage" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.lastFileCoverage">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>lastFileCoverage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastFileCoverage = function () {
    return this.coverState;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.lastSourceMap" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.lastSourceMap">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>lastSourceMap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastSourceMap = function () {
    return this.sourceMap;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.locationsForNodes" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.locationsForNodes">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>locationsForNodes
        <span class="apidocSignatureSpan">(nodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">locationsForNodes = function (nodes) {
    var ret = [],
        i;
    for (i = 0; i &lt; nodes.length; i += 1) {
        ret.push(nodes[i].loc);
    }
    return ret;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.logicalExpressionBranchInjector" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.logicalExpressionBranchInjector">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>logicalExpressionBranchInjector
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logicalExpressionBranchInjector = function (node, walker) {
    var parent = walker.parent(),
        leaves = [],
        bName,
        tuple,
        i;

    this.maybeSkipNode(node, &apos;next&apos;);

    if (parent &amp;&amp; parent.node.type === SYNTAX.LogicalExpression.name) {
        //already covered
        return;
    }

    this.findLeaves(node, leaves);
    bName = this.branchName(&apos;binary-expr&apos;,
        walker.startLineForNode(node),
        this.locationsForNodes(leaves.map(function (item) { return item.node; }))
    );
    for (i = 0; i &lt; leaves.length; i += 1) {
        tuple = leaves[i];
        tuple.parent[tuple.property] = astgen.sequence(this.branchIncrementExprAst(bName, i), tuple.node);
        tuple.node.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, i));
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.loopBlockConverter" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.loopBlockConverter">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>loopBlockConverter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loopBlockConverter = function (node) {
    node.body = this.convertToBlock(node.body);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.maybeAddSkip" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.maybeAddSkip">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>maybeAddSkip
        <span class="apidocSignatureSpan">(branchLocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeAddSkip = function (branchLocation) {
    return function (node) {
        var alreadyIgnoring = !!this.currentState.ignoring,
            hint = this.currentState.currentHint,
            ignoreThis = !alreadyIgnoring &amp;&amp; hint &amp;&amp; hint.type === &apos;next&apos;;
        if (ignoreThis) {
            this.startIgnore();
            node.postprocessor = this.endIgnore;
        }
        if (ignoreThis || alreadyIgnoring) {
            branchLocation.skip = true;
        }
    };
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.maybeAddType" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.maybeAddType">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>maybeAddType
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeAddType = function (node) {
    var props = node.properties,
        i,
        child;
    for (i = 0; i &lt; props.length; i += 1) {
        child = props[i];
        if (!child.type) {
            child.type = SYNTAX.Property.name;
        }
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.maybeSkipNode" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.maybeSkipNode">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>maybeSkipNode
        <span class="apidocSignatureSpan">(node, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeSkipNode = function (node, type) {
    var alreadyIgnoring = !!this.currentState.ignoring,
        hint = this.currentState.currentHint,
        ignoreThis = !alreadyIgnoring &amp;&amp; hint &amp;&amp; hint.type === type;

    if (ignoreThis) {
        this.startIgnore();
        node.postprocessor = this.endIgnore;
        return true;
    }
    return false;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.paranoidHandlerCheck" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.paranoidHandlerCheck">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>paranoidHandlerCheck
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">paranoidHandlerCheck = function (node) {
    // if someone is using an older esprima on the browser
    // convert handlers array to single handler attribute
    // containing its first element
<span class="apidocCodeCommentSpan">    /* istanbul ignore next */
</span>    if (!node.handler &amp;&amp; node.handlers) {
        node.handler = node.handlers[0];
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.skipInit" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.skipInit">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>skipInit
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipInit = function (node) {
    if (node.init) {
        node.init.skipWalk = true;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.skipLeft" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.skipLeft">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>skipLeft
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipLeft = function (node) {
    node.left.skipWalk = true;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.splice" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.splice">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>splice
        <span class="apidocSignatureSpan">(statements, node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">splice = function (statements, node, walker) {
    var targetNode = walker.isLabeled() ? walker.parent().node : node;
    targetNode.prepend = targetNode.prepend || [];
    pushAll(targetNode.prepend, statements);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

Reference.prototype.replace = function replace(node) {
    this.parent[this.key] = node;
};

Reference.prototype.remove = function remove() {
    if (isArray(this.parent)) {
        this.parent.<span class="apidocCodeKeywordSpan">splice</span>(this.key, 1);
        return true;
    } else {
        this.replace(null);
        return false;
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.startIgnore" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.startIgnore">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>startIgnore
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startIgnore = function () {
    this.currentState.ignoring += 1;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.statementName" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.statementName">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>statementName
        <span class="apidocSignatureSpan">(location, initValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statementName = function (location, initValue) {
    var sName,
        ignoring = !!this.currentState.ignoring;

    location.skip = ignoring || undefined;
    initValue = initValue || 0;
    this.currentState.statement += 1;
    sName = this.currentState.statement;
    this.coverState.statementMap[sName] = location;
    this.coverState.s[sName] = initValue;
    return sName;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.switchBranchInjector" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.switchBranchInjector">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>switchBranchInjector
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchBranchInjector = function (node, walker) {
    var cases = node.cases,
        bName,
        i;

    if (!(cases &amp;&amp; cases.length &gt; 0)) {
        return;
    }
    bName = this.branchName(&apos;switch&apos;, walker.startLineForNode(node), this.locationsForNodes(cases));
    for (i = 0; i &lt; cases.length; i += 1) {
        cases[i].branchLocation = this.branchLocationFor(bName, i);
        cases[i].consequent.unshift(astgen.statement(this.branchIncrementExprAst(bName, i)));
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.switchCaseInjector" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.switchCaseInjector">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>switchCaseInjector
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchCaseInjector = function (node) {
    var location = node.branchLocation;
    delete node.branchLocation;
    if (this.maybeSkipNode(node, &apos;next&apos;)) {
        location.skip = true;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.Instrumenter.prototype.withBlockConverter" id="apidoc.elem.istanbul-lite.Instrumenter.prototype.withBlockConverter">
        function <span class="apidocSignatureSpan">istanbul-lite.Instrumenter.prototype.</span>withBlockConverter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withBlockConverter = function (node) {
    node.body = this.convertToBlock(node.body);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.cliDict" id="apidoc.module.istanbul-lite.cliDict">module istanbul-lite.cliDict</a></h1>


    <h2>
        <a href="#apidoc.elem.istanbul-lite.cliDict.cover" id="apidoc.elem.istanbul-lite.cliDict.cover">
        function <span class="apidocSignatureSpan">istanbul-lite.cliDict.</span>cover
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cover = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;script&gt;
 * will run and cover &lt;script&gt;
 */
</span>    let tmp;
    try {
        tmp = JSON.parse(local.fs.readFileSync(&quot;package.json&quot;, &quot;utf8&quot;));
        process.env.npm_package_nameLib = (
            process.env.npm_package_nameLib
            || tmp.nameLib
            || tmp.name.replace((
                /-/g
            ), &quot;_&quot;)
        );
    } catch (ignore) {}
    process.env.npm_config_mode_coverage = (
        process.env.npm_config_mode_coverage
        || process.env.npm_package_nameLib
        || &quot;all&quot;
    );
    // add coverage hook to require
    local.__istanbul_moduleExtensionsJs = (
        local.__istanbul_module._extensions[&quot;.js&quot;]
    );
    local.__istanbul_module._extensions[&quot;.js&quot;] = function (module, file) {
        if (typeof file === &quot;string&quot; &amp;&amp; (
            file.indexOf(process.env.npm_config_mode_coverage_dir) === 0 || (
                file.indexOf(process.cwd() + local.path.sep) === 0
                &amp;&amp; (
                    process.env.npm_config_mode_coverage === &quot;node_modules&quot;
                    || file.indexOf(
                        local.path.resolve(&quot;node_modules&quot;) + local.path.sep
                    ) !== 0
                )
            )
        )) {
            module._compile(local.instrumentInPackage(
                local.fs.readFileSync(file, &quot;utf8&quot;),
                file
            ), file);
            return;
        }
        local.__istanbul_moduleExtensionsJs(module, file);
    };
    // init process.argv
    process.argv.splice(1, 2);
    process.argv[1] = local.path.resolve(process.argv[1]);
    console.error(&quot;\nistanbul - covering $ &quot; + process.argv.join(&quot; &quot;));
    // create coverage on exit
    process.on(&quot;exit&quot;, function () {
        local.coverageReportCreate({
            coverage: globalThis.__coverage__
        });
    });
    // re-init cli
    local.__istanbul_module.runMain();
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.cliDict.instrument" id="apidoc.elem.istanbul-lite.cliDict.instrument">
        function <span class="apidocSignatureSpan">istanbul-lite.cliDict.</span>instrument
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrument = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;script&gt;
 * will instrument &lt;script&gt; and print result to stdout
 */
</span>    process.argv[3] = local.path.resolve(process.argv[3]);
    process.stdout.write(local.instrumentSync(
        local.fs.readFileSync(process.argv[3], &quot;utf8&quot;),
        process.argv[3]
    ));
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.cliDict.report" id="apidoc.elem.istanbul-lite.cliDict.report">
        function <span class="apidocSignatureSpan">istanbul-lite.cliDict.</span>report
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">report = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;coverageJson&gt;
 * will create coverage-report from file &lt;coverageJson&gt;
 */
</span>    process.argv[3] = local.path.resolve(process.argv[3]);
    globalThis.__coverage__ = JSON.parse(
        local.fs.readFileSync(process.argv[3])
    );
    globalThis.__coverageInclude__ = {};
    Object.keys(globalThis.__coverage__).forEach(function (file) {
        globalThis.__coverageInclude__[file] = 1;
    });
    local.coverageReportCreate({
        coverage: globalThis.__coverage__
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.cliDict.test" id="apidoc.elem.istanbul-lite.cliDict.test">
        function <span class="apidocSignatureSpan">istanbul-lite.cliDict.</span>test
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;script&gt;
 * will run and cover &lt;script&gt; if env-var $npm_config_mode_coverage is set
 */
</span>    if (process.env.npm_config_mode_coverage) {
        process.argv[2] = &quot;cover&quot;;
        // re-init cli
        local.cliDict[process.argv[2]]();
        return;
    }
    // restart node with __filename removed from process.argv
    process.argv.splice(1, 2);
    process.argv[1] = local.path.resolve(process.argv[1]);
    // re-init cli
    local.__istanbul_module.runMain();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code &lt; 65) { return code === 36 }
  if (code &lt; 91) { return true }
  if (code &lt; 97) { return code === 95 }
  if (code &lt; 123) { return true }
  if (code &lt;= 0xffff) { return code &gt;= 0xaa &amp;&amp; nonASCIIidentifierStart.<span class="apidocCodeKeywordSpan">test</span
>(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.escodegen" id="apidoc.module.istanbul-lite.escodegen">module istanbul-lite.escodegen</a></h1>




    <h2>
        <a href="#apidoc.elem.istanbul-lite.escodegen.attachComments" id="apidoc.elem.istanbul-lite.escodegen.attachComments">
        function <span class="apidocSignatureSpan">istanbul-lite.escodegen.</span>attachComments
        <span class="apidocSignatureSpan">(tree, providedComments, tokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attachComments(tree, providedComments, tokens) {
    // At first, we should calculate extended comment ranges.
    var comments = [], comment, len, i, cursor;

    if (!tree.range) {
        throw new Error(&apos;attachComments needs range information&apos;);
    }

    // tokens array is empty, we attach comments to tree as &apos;leadingComments&apos;
    if (!tokens.length) {
        if (providedComments.length) {
            for (i = 0, len = providedComments.length; i &lt; len; i += 1) {
                comment = deepCopy(providedComments[i]);
                comment.extendedRange = [0, tree.range[0]];
                comments.push(comment);
            }
            tree.leadingComments = comments;
        }
        return tree;
    }

    for (i = 0, len = providedComments.length; i &lt; len; i += 1) {
        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
    }

    // This is based on John Freeman&apos;s implementation.
    cursor = 0;
    traverse(tree, {
        enter: function (node) {
            var comment;

            while (cursor &lt; comments.length) {
                comment = comments[cursor];
                if (comment.extendedRange[1] &gt; node.range[0]) {
                    break;
                }

                if (comment.extendedRange[1] === node.range[0]) {
                    if (!node.leadingComments) {
                        node.leadingComments = [];
                    }
                    node.leadingComments.push(comment);
                    comments.splice(cursor, 1);
                } else {
                    cursor += 1;
                }
            }

            // already out of owned node
            if (cursor === comments.length) {
                return VisitorOption.Break;
            }

            if (comments[cursor].extendedRange[0] &gt; node.range[1]) {
                return VisitorOption.Skip;
            }
        }
    });

    cursor = 0;
    traverse(tree, {
        leave: function (node) {
            var comment;

            while (cursor &lt; comments.length) {
                comment = comments[cursor];
                if (node.range[1] &lt; comment.extendedRange[0]) {
                    break;
                }

                if (node.range[1] === comment.extendedRange[0]) {
                    if (!node.trailingComments) {
                        node.trailingComments = [];
                    }
                    node.trailingComments.push(comment);
                    comments.splice(cursor, 1);
                } else {
                    cursor += 1;
                }
            }

            // already out of owned node
            if (cursor === comments.length) {
                return VisitorOption.Break;
            }

            if (comments[cursor].extendedRange[0] &gt; node.range[1]) {
                return VisitorOption.Skip;
            }
        }
    });

    return tree;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.escodegen.generate" id="apidoc.elem.istanbul-lite.escodegen.generate">
        function <span class="apidocSignatureSpan">istanbul-lite.escodegen.</span>generate
        <span class="apidocSignatureSpan">(node, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generate(node, options) {
    var defaultOptions = getDefaultOptions(), result, pair;

    if (options != null) {
        // Obsolete options
        //
        //   `options.indent`
        //   `options.base`
        //
        // Instead of them, we can use `option.format.indent`.
        if (typeof options.indent === &apos;string&apos;) {
            defaultOptions.format.indent.style = options.indent;
        }
        if (typeof options.base === &apos;number&apos;) {
            defaultOptions.format.indent.base = options.base;
        }
        options = updateDeeply(defaultOptions, options);
        indent = options.format.indent.style;
        if (typeof options.base === &apos;string&apos;) {
            base = options.base;
        } else {
            base = stringRepeat(indent, options.format.indent.base);
        }
    } else {
        options = defaultOptions;
        indent = options.format.indent.style;
        base = stringRepeat(indent, options.format.indent.base);
    }
    json = options.format.json;
    renumber = options.format.renumber;
    hexadecimal = json ? false : options.format.hexadecimal;
    quotes = json ? &apos;double&apos; : options.format.quotes;
    escapeless = options.format.escapeless;
    newline = options.format.newline;
    space = options.format.space;
    if (options.format.compact) {
        newline = space = indent = base = &apos;&apos;;
    }
    parentheses = options.format.parentheses;
    semicolons = options.format.semicolons;
    safeConcatenation = options.format.safeConcatenation;
    directive = options.directive;
    parse = json ? null : options.parse;
    sourceMap = options.sourceMap;
    sourceCode = options.sourceCode;
    preserveBlankLines = options.format.preserveBlankLines &amp;&amp; sourceCode !== null;
    extra = options;

    if (sourceMap) {
        if (!exports.browser) {
            // We assume environment is node.js
            // And prevent from including source-map by browserify
            SourceNode = require(&apos;source-map&apos;).SourceNode;
        } else {
            SourceNode = global.sourceMap.SourceNode;
        }
    }

    result = generateInternal(node);

    if (!sourceMap) {
        pair = {code: result.toString(), map: null};
        return options.sourceMapWithCode ? pair : pair.code;
    }

    pair = result.toStringWithSourceMap({
        file: options.file,
        sourceRoot: options.sourceMapRoot
    });

    if (options.sourceContent) {
        pair.map.setSourceContent(options.sourceMap,
                                  options.sourceContent);
    }

    if (options.sourceMapWithCode) {
        return pair;
    }

    return pair.map.toString();
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.esprima" id="apidoc.module.istanbul-lite.esprima">module istanbul-lite.esprima</a></h1>


    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Node" id="apidoc.elem.istanbul-lite.esprima.Node">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>Node
        <span class="apidocSignatureSpan">(parser, pos, loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Node(parser, pos, loc) {
  this.type = &quot;&quot;;
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser" id="apidoc.elem.istanbul-lite.esprima.Parser">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>Parser
        <span class="apidocSignatureSpan">(options, input, startPos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords[options.ecmaVersion &gt;= 6 ? 6 : options.sourceType === &quot;module&quot; ? &quot;5module&quot; : 5]);
  var reserved = &quot;&quot;;
  if (options.allowReserved !== true) {
    for (var v = options.ecmaVersion;; v--)
      { if (reserved = reservedWords[v]) { break } }
    if (options.sourceType === &quot;module&quot;) { reserved += &quot; await&quot;; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + &quot; &quot; : &quot;&quot;) + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + &quot; &quot; + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf(&quot;\n&quot;, startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it&apos;s a module code.
  this.inModule = options.sourceType === &quot;module&quot;;
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = {};

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 &amp;&amp; options.allowHashBang &amp;&amp; this.input.slice(0, 2) === &quot;#!&quot;)
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Position" id="apidoc.elem.istanbul-lite.esprima.Position">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>Position
        <span class="apidocSignatureSpan">(line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Position(line, col) {
  this.line = line;
  this.column = col;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.SourceLocation" id="apidoc.elem.istanbul-lite.esprima.SourceLocation">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>SourceLocation
        <span class="apidocSignatureSpan">(p, start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.TokContext" id="apidoc.elem.istanbul-lite.esprima.TokContext">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>TokContext
        <span class="apidocSignatureSpan">(token, isExpr, preserveSpace, override, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Token" id="apidoc.elem.istanbul-lite.esprima.Token">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>Token
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.TokenType" id="apidoc.elem.istanbul-lite.esprima.TokenType">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>TokenType
        <span class="apidocSignatureSpan">(label, conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.getLineInfo" id="apidoc.elem.istanbul-lite.esprima.getLineInfo">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>getLineInfo
        <span class="apidocSignatureSpan">(input, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match &amp;&amp; match.index &lt; offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur)
    }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.isIdentifierChar" id="apidoc.elem.istanbul-lite.esprima.isIdentifierChar">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>isIdentifierChar
        <span class="apidocSignatureSpan">(code, astral)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIdentifierChar(code, astral) {
  if (code &lt; 48) { return code === 36 }
  if (code &lt; 58) { return true }
  if (code &lt; 65) { return false }
  if (code &lt; 91) { return true }
  if (code &lt; 97) { return code === 95 }
  if (code &lt; 123) { return true }
  if (code &lt;= 0xffff) { return code &gt;= 0xaa &amp;&amp; nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.isIdentifierStart" id="apidoc.elem.istanbul-lite.esprima.isIdentifierStart">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>isIdentifierStart
        <span class="apidocSignatureSpan">(code, astral)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIdentifierStart(code, astral) {
  if (code &lt; 65) { return code === 36 }
  if (code &lt; 91) { return true }
  if (code &lt; 97) { return code === 95 }
  if (code &lt; 123) { return true }
  if (code &lt;= 0xffff) { return code &gt;= 0xaa &amp;&amp; nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.isNewLine" id="apidoc.elem.istanbul-lite.esprima.isNewLine">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>isNewLine
        <span class="apidocSignatureSpan">(code, ecma2019String)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || (!ecma2019String &amp;&amp; (code === 0x2028 || code === 0x2029))
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.parse" id="apidoc.elem.istanbul-lite.esprima.parse">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>parse
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(input, options) {
  return Parser.parse(input, options)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        return dflt;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to read pathname
    try {
        return (
            type === &quot;json&quot;
            ? JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(pathname, &quot;utf8&quot;))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
};
local.fsRmrfSync = function (pathname) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.parseExpressionAt" id="apidoc.elem.istanbul-lite.esprima.parseExpressionAt">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>parseExpressionAt
        <span class="apidocSignatureSpan">(input, pos, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseExpressionAt(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  return Parser.<span class="apidocCodeKeywordSpan">parseExpressionAt</span>(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser.tokenizer(input, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.tokenizer" id="apidoc.elem.istanbul-lite.esprima.tokenizer">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>tokenizer
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tokenizer(input, options) {
  return Parser.tokenizer(input, options)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return Parser.parseExpressionAt(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser.<span class="apidocCodeKeywordSpan">tokenizer</span>(input, options)
}

exports.Node = Node;
exports.Parser = Parser;
exports.Position = Position;
exports.SourceLocation = SourceLocation;
exports.TokContext = TokContext;
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.esprima.Parser" id="apidoc.module.istanbul-lite.esprima.Parser">module istanbul-lite.esprima.Parser</a></h1>


    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.Parser" id="apidoc.elem.istanbul-lite.esprima.Parser.Parser">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>Parser
        <span class="apidocSignatureSpan">(options, input, startPos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords[options.ecmaVersion &gt;= 6 ? 6 : options.sourceType === &quot;module&quot; ? &quot;5module&quot; : 5]);
  var reserved = &quot;&quot;;
  if (options.allowReserved !== true) {
    for (var v = options.ecmaVersion;; v--)
      { if (reserved = reservedWords[v]) { break } }
    if (options.sourceType === &quot;module&quot;) { reserved += &quot; await&quot;; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + &quot; &quot; : &quot;&quot;) + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + &quot; &quot; + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf(&quot;\n&quot;, startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it&apos;s a module code.
  this.inModule = options.sourceType === &quot;module&quot;;
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = {};

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 &amp;&amp; options.allowHashBang &amp;&amp; this.input.slice(0, 2) === &quot;#!&quot;)
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.extend" id="apidoc.elem.istanbul-lite.esprima.Parser.extend">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.</span>extend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];

  var cls = this;
  for (var i = 0; i &lt; plugins.length; i++) { cls = plugins[i](cls); }
  return cls
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.parse" id="apidoc.elem.istanbul-lite.esprima.Parser.parse">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.</span>parse
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse (input, options) {
  return new this(options, input).parse()
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        return dflt;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to read pathname
    try {
        return (
            type === &quot;json&quot;
            ? JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(pathname, &quot;utf8&quot;))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
};
local.fsRmrfSync = function (pathname) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.parseExpressionAt" id="apidoc.elem.istanbul-lite.esprima.Parser.parseExpressionAt">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.</span>parseExpressionAt
        <span class="apidocSignatureSpan">(input, pos, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression()
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  return Parser.<span class="apidocCodeKeywordSpan">parseExpressionAt</span>(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser.tokenizer(input, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.tokenizer" id="apidoc.elem.istanbul-lite.esprima.Parser.tokenizer">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.</span>tokenizer
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tokenizer (input, options) {
  return new this(options, input)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return Parser.parseExpressionAt(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser.<span class="apidocCodeKeywordSpan">tokenizer</span>(input, options)
}

exports.Node = Node;
exports.Parser = Parser;
exports.Position = Position;
exports.SourceLocation = SourceLocation;
exports.TokContext = TokContext;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.esprima.Parser.prototype" id="apidoc.module.istanbul-lite.esprima.Parser.prototype">module istanbul-lite.esprima.Parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.adaptDirectivePrologue" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.adaptDirectivePrologue">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>adaptDirectivePrologue
        <span class="apidocSignatureSpan">(statements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(statements) {
  for (var i = 0; i &lt; statements.length &amp;&amp; this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i &lt; list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, (&quot;Export &apos;&quot; + name + &quot;&apos; is not defined
&quot;));
      } }
  this.<span class="apidocCodeKeywordSpan">adaptDirectivePrologue</span>(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, &quot;Program&quot;)
};

var loopLabel = {kind: &quot;loop&quot;}, switchLabel = {kind: &quot;switch&quot;};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.afterTrailingComma" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.afterTrailingComma">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>afterTrailingComma
        <span class="apidocSignatureSpan">(tokType, notNext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  pp$1.parseExportSpecifiers = function(exports) {
    var nodes = [], first = true;
    // export { x, y as z } [from &apos;...&apos;]
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
if (!first) {
  this.expect(types.comma);
  if (this.<span class="apidocCodeKeywordSpan">afterTrailingComma</span>(types.braceR)) { break }
} else { first = false; }

var node = this.startNode();
node.local = this.parseIdent(true);
node.exported = this.eatContextual(&quot;as&quot;) ? this.parseIdent(true) : node.local;
this.checkExport(exports, node.exported.name, node.exported.start);
nodes.push(this.finishNode(node, &quot;ExportSpecifier&quot;));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.braceIsBlock" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.braceIsBlock">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>braceIsBlock
        <span class="apidocSignatureSpan">(prevType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat)
    { return true }
  if (prevType === types.colon &amp;&amp; (parent === types$1.b_stat || parent === types$1.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name &amp;&amp; exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types._return || prevType === types.name &amp;&amp; this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType ===
types.arrow)
    { return true }
  if (prevType === types.braceL)
    { return parent === types$1.b_stat }
  if (prevType === types._var || prevType === types._const || prevType === types.name)
    { return false }
  return !this.exprAllowed
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (out === types$1.b_stat &amp;&amp; this.curContext().token === &quot;function&quot;) {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function(prevType) {
  this.context.push(this.<span class="apidocCodeKeywordSpan">braceIsBlock</span>(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function() {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.buildBinary" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.buildBinary">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>buildBinary
        <span class="apidocSignatureSpan">(startPos, startLoc, left, right, op, logical)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? &quot;LogicalExpression&quot; : &quot;BinaryExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (prec != null &amp;&amp; (!noIn || this.type !== types._in)) {
    if (prec &gt; minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.<span class="apidocCodeKeywordSpan">buildBinary</span>(leftStartPos, leftStartLoc, left, right, op, logical
);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
};

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.canInsertSemicolon" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.canInsertSemicolon">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>canInsertSemicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp.insertSemicolon = function() {
  if (this.<span class="apidocCodeKeywordSpan">canInsertSemicolon</span>()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkExport" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkExport">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkExport
        <span class="apidocSignatureSpan">(exports, name, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(exports, name, pos) {
  if (!exports) { return }
  if (has(exports, name))
    { this.raiseRecoverable(pos, &quot;Duplicate export &apos;&quot; + name + &quot;&apos;&quot;); }
  exports[name] = true;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.expectContextual(&quot;from&quot;);
  if (this.type !== types.string) { this.unexpected(); }
  node.source = this.parseExprAtom();
  this.semicolon();
  return this.finishNode(node, &quot;ExportAllDeclaration&quot;)
}
if (this.eat(types._default)) { // export default ...
  this.<span class="apidocCodeKeywordSpan">checkExport</span>(exports, &quot;default&quot;, this.lastTokStart);
  var isAsync;
  if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) { this.next(); }
    node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types._class) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkExpressionErrors" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkExpressionErrors">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkExpressionErrors
        <span class="apidocSignatureSpan">(refDestructuringErrors, andThrow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign &gt;= 0 || doubleProto &gt;= 0 }
  if (shorthandAssign &gt;= 0)
    { this.raise(shorthandAssign, &quot;Shorthand property assignments are valid only in destructuring patterns&quot;); }
  if (doubleProto &gt;= 0)
    { this.raiseRecoverable(doubleProto, &quot;Redefinition of __proto__ property&quot;); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt &gt; -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init)
  } else {
    this.<span class="apidocCodeKeywordSpan">checkExpressionErrors</span>(refDestructuringErrors, true);
  }
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkLVal" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkLVal">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkLVal
        <span class="apidocSignatureSpan">(expr, bindingType, checkClashes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case &quot;Identifier&quot;:
    if (bindingType === BIND_LEXICAL &amp;&amp; expr.name === &quot;let&quot;)
      { this.raiseRecoverable(expr.start, &quot;let is disallowed as a lexically bound name&quot;); }
    if (this.strict &amp;&amp; this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (bindingType ? &quot;Binding &quot; : &quot;Assigning to &quot;) + expr.name + &quot; in strict mode&quot;); }
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        { this.raiseRecoverable(expr.start, &quot;Argument name clash&quot;); }
      checkClashes[expr.name] = true;
    }
    if (bindingType !== BIND_NONE &amp;&amp; bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
    break

  case &quot;MemberExpression&quot;:
    if (bindingType) { this.raiseRecoverable(expr.start, &quot;Binding member expression&quot;); }
    break

  case &quot;ObjectPattern&quot;:
    for (var i = 0, list = expr.properties; i &lt; list.length; i += 1)
      {
    var prop = list[i];

    this.checkLVal(prop, bindingType, checkClashes);
  }
    break

  case &quot;Property&quot;:
    // AssignmentProperty has type === &quot;Property&quot;
    this.checkLVal(expr.value, bindingType, checkClashes);
    break

  case &quot;ArrayPattern&quot;:
    for (var i$1 = 0, list$1 = expr.elements; i$1 &lt; list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
    }
    break

  case &quot;AssignmentPattern&quot;:
    this.checkLVal(expr.left, bindingType, checkClashes);
    break

  case &quot;RestElement&quot;:
    this.checkLVal(expr.argument, bindingType, checkClashes);
    break

  case &quot;ParenthesizedExpression&quot;:
    this.checkLVal(expr.expression, bindingType, checkClashes);
    break

  default:
    this.raise(expr.start, (bindingType ? &quot;Binding&quot; : &quot;Assigning to&quot;) + &quot; rvalue&quot;);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) {
    if (this.options.ecmaVersion &gt;= 9) {
      if (this.type === types._in) {
        if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt &gt; -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.<span class="apidocCodeKeywordSpan">checkLVal</span>(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkLocalExport" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkLocalExport">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkLocalExport
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  // scope.functions must be empty as Module code is always strict.
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &amp;&amp;
      this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  } else {
    for (var i = 0, list = node.specifiers; i &lt; list.length; i += 1) {
      // check for keywords used as local names
      var spec = list[i];

      this.checkUnreserved(spec.local);
      // check if export is defined
      this.<span class="apidocCodeKeywordSpan">checkLocalExport</span>(spec.local);
    }

    node.source = null;
  }
  this.semicolon();
}
return this.finishNode(node, &quot;ExportNamedDeclaration&quot;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkParams" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkParams">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkParams
        <span class="apidocSignatureSpan">(node, allowDuplicates)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, allowDuplicates) {
  var nameHash = {};
  for (var i = 0, list = node.params; i &lt; list.length; i += 1)
    {
    var param = list[i];

    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
var isExpression = isArrowFunction &amp;&amp; this.type !== types.braceL;
var oldStrict = this.strict, useStrict = false;

if (isExpression) {
  node.body = this.parseMaybeAssign();
  node.expression = true;
  this.<span class="apidocCodeKeywordSpan">checkParams</span>(node, false);
} else {
  var nonSimple = this.options.ecmaVersion &gt;= 7 &amp;&amp; !this.isSimpleParamList(node.params);
  if (!oldStrict || nonSimple) {
    useStrict = this.strictDirective(this.end);
    // If this is a strict mode function, verify that argument names
    // are not repeated, and it does not try to bind the words `eval`
    // or `arguments`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkPatternErrors" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkPatternErrors">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkPatternErrors
        <span class="apidocSignatureSpan">(refDestructuringErrors, isAssign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma &gt; -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, &quot;Comma is not permitted after the rest element&quot;); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens &gt; -1) { this.raiseRecoverable(parens, &quot;Parenthesized pattern&quot;); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      case &quot;ObjectPattern&quot;:
      case &quot;ArrayPattern&quot;:
      case &quot;RestElement&quot;:
break

      case &quot;ObjectExpression&quot;:
node.type = &quot;ObjectPattern&quot;;
if (refDestructuringErrors) { this.<span class="apidocCodeKeywordSpan">checkPatternErrors</span>(refDestructuringErrors, true); }
for (var i = 0, list = node.properties; i &lt; list.length; i += 1) {
  var prop = list[i];

this.toAssignable(prop, isBinding);
  // Early error:
  //   AssignmentRestProperty[Yield, Await] :
  //     `...` DestructuringAssignmentTarget[Yield, Await]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkPatternExport" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkPatternExport">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkPatternExport
        <span class="apidocSignatureSpan">(exports, pat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(exports, pat) {
  var type = pat.type;
  if (type === &quot;Identifier&quot;)
    { this.checkExport(exports, pat.name, pat.start); }
  else if (type === &quot;ObjectPattern&quot;)
    { for (var i = 0, list = pat.properties; i &lt; list.length; i += 1)
      {
        var prop = list[i];

        this.checkPatternExport(exports, prop);
      } }
  else if (type === &quot;ArrayPattern&quot;)
    { for (var i$1 = 0, list$1 = pat.elements; i$1 &lt; list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this.checkPatternExport(exports, elt); }
    } }
  else if (type === &quot;Property&quot;)
    { this.checkPatternExport(exports, pat.value); }
  else if (type === &quot;AssignmentPattern&quot;)
    { this.checkPatternExport(exports, pat.left); }
  else if (type === &quot;RestElement&quot;)
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === &quot;ParenthesizedExpression&quot;)
    { this.checkPatternExport(exports, pat.expression); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    if (type === &quot;Identifier&quot;)
{ this.checkExport(exports, pat.name, pat.start); }
    else if (type === &quot;ObjectPattern&quot;)
{ for (var i = 0, list = pat.properties; i &lt; list.length; i += 1)
  {
    var prop = list[i];

    this.<span class="apidocCodeKeywordSpan">checkPatternExport</span>(exports, prop);
  } }
    else if (type === &quot;ArrayPattern&quot;)
{ for (var i$1 = 0, list$1 = pat.elements; i$1 &lt; list$1.length; i$1 += 1) {
  var elt = list$1[i$1];

    if (elt) { this.checkPatternExport(exports, elt); }
} }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkPropClash" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkPropClash">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkPropClash
        <span class="apidocSignatureSpan">(prop, propHash, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion &gt;= 9 &amp;&amp; prop.type === &quot;SpreadElement&quot;)
    { return }
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case &quot;Identifier&quot;: name = key.name; break
  case &quot;Literal&quot;: name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion &gt;= 6) {
    if (name === &quot;__proto__&quot; &amp;&amp; kind === &quot;init&quot;) {
      if (propHash.proto) {
        if (refDestructuringErrors &amp;&amp; refDestructuringErrors.doubleProto &lt; 0) { refDestructuringErrors.doubleProto = key.start; }
        // Backwards-compat kludge. Can be removed in version 6.0
        else { this.raiseRecoverable(key.start, &quot;Redefinition of __proto__ property&quot;); }
      }
      propHash.proto = true;
    }
    return
  }
  name = &quot;$&quot; + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === &quot;init&quot;) {
      redefinition = this.strict &amp;&amp; other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, &quot;Redefinition of property&quot;); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.<span class="apidocCodeKeywordSpan">checkPropClash</span>(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? &quot;ObjectPattern&quot; : &quot;ObjectExpression&quot;)
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkUnreserved" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkUnreserved">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkUnreserved
        <span class="apidocSignatureSpan">(ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator &amp;&amp; name === &quot;yield&quot;)
    { this.raiseRecoverable(start, &quot;Cannot use &apos;yield&apos; as identifier inside a generator&quot;); }
  if (this.inAsync &amp;&amp; name === &quot;await&quot;)
    { this.raiseRecoverable(start, &quot;Cannot use &apos;await&apos; as identifier inside an async function&quot;); }
  if (this.keywords.test(name))
    { this.raise(start, (&quot;Unexpected keyword &apos;&quot; + name + &quot;&apos;&quot;)); }
  if (this.options.ecmaVersion &lt; 6 &amp;&amp;
    this.input.slice(start, end).indexOf(&quot;\\&quot;) !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync &amp;&amp; name === &quot;await&quot;)
      { this.raiseRecoverable(start, &quot;Cannot use keyword &apos;await&apos; outside an async function&quot;); }
    this.raiseRecoverable(start, (&quot;The keyword &apos;&quot; + name + &quot;&apos; is reserved&quot;));
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (this.type !== types.string) { this.unexpected(); }
  node.source = this.parseExprAtom();
} else {
  for (var i = 0, list = node.specifiers; i &lt; list.length; i += 1) {
    // check for keywords used as local names
    var spec = list[i];

    this.<span class="apidocCodeKeywordSpan">checkUnreserved</span>(spec.local);
    // check if export is defined
    this.checkLocalExport(spec.local);
  }

  node.source = null;
}
this.semicolon();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkVariableExport" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkVariableExport">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkVariableExport
        <span class="apidocSignatureSpan">(exports, decls)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(exports, decls) {
  if (!exports) { return }
  for (var i = 0, list = decls; i &lt; list.length; i += 1)
    {
    var decl = list[i];

    this.checkPatternExport(exports, decl.id);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  }
  return this.finishNode(node, &quot;ExportDefaultDeclaration&quot;)
}
// export var|const|let|function|class ...
if (this.shouldParseExportStatement()) {
  node.declaration = this.parseStatement(null);
  if (node.declaration.type === &quot;VariableDeclaration&quot;)
    { this.<span class="apidocCodeKeywordSpan">checkVariableExport</span>(exports, node.declaration.declarations); }
  else
    { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
  node.specifiers = [];
  node.source = null;
} else { // export { x, y as z } [from &apos;...&apos;]
  node.declaration = null;
  node.specifiers = this.parseExportSpecifiers(exports);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkYieldAwaitInDefaultParams" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.checkYieldAwaitInDefaultParams">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>checkYieldAwaitInDefaultParams
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.yieldPos &amp;&amp; (!this.awaitPos || this.yieldPos &lt; this.awaitPos))
    { this.raise(this.yieldPos, &quot;Yield expression cannot be a default value&quot;); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, &quot;Await expression cannot be a default value&quot;); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement &amp; FUNC_STATEMENT) ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot
;)
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion &gt;= 8);
  this.<span class="apidocCodeKeywordSpan">checkYieldAwaitInDefaultParams</span>();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
  this.next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.curContext" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.curContext">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>curContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return this.context[this.context.length - 1]
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  var pp$7 = Parser.prototype;

  pp$7.initialContext = function() {
return [types$1.b_stat]
  };

  pp$7.braceIsBlock = function(prevType) {
var parent = this.<span class="apidocCodeKeywordSpan">curContext</span>();
if (parent === types$1.f_expr || parent === types$1.f_stat)
  { return true }
if (prevType === types.colon &amp;&amp; (parent === types$1.b_stat || parent === types$1.b_expr))
  { return !parent.isExpr }

// The check for `tt.name &amp;&amp; exprAllowed` detects whether we are
// after a `yield` or `of` construct. See the `updateContext` for
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.curPosition" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.curPosition">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>curPosition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
this.type = types.eof;
// For tokens that include more information than their type, the value
this.value = null;
// Its start and end offset
this.start = this.end = this.pos;
// And, if locations are used, the {line, column} object
// corresponding to those offsets
this.startLoc = this.endLoc = this.<span class="apidocCodeKeywordSpan">curPosition</span>();

// Position information for the previous token
this.lastTokEndLoc = this.lastTokStartLoc = null;
this.lastTokStart = this.lastTokEnd = this.pos;

// The context stack is used to superficially track syntactic
// context to predict whether a regular expression is allowed in a
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.currentScope" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.currentScope">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>currentScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return this.scopeStack[this.scopeStack.length - 1]
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_SUPER) &gt; 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.<span class="apidocCodeKeywordSpan
">currentScope</span>()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags &amp; SCOPE_FUNCTION
) &gt; 0 };

Parser.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.currentThisScope" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.currentThisScope">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>currentThisScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags &amp; SCOPE_VAR &amp;&amp; !(scope.flags &amp; SCOPE_ARROW)) { return scope }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.<span class="apidocCodeKeywordSpan">currentThisScope</span>().flags
 &amp; SCOPE_SUPER) &gt; 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags &amp; SCOPE_FUNCTION
) &gt; 0 };

Parser.extend = function extend () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.currentVarScope" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.currentVarScope">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>currentVarScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags &amp; SCOPE_VAR) { return scope }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.<span class="apidocCodeKeywordSpan">currentVarScope</span>().flags
 &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_SUPER) &gt; 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

// Switch to a getter for 7.0.0.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.declareName" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.declareName">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>declareName
        <span class="apidocSignatureSpan">(name, bindingType, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) &gt; -1 || scope.functions.indexOf(name) &gt; -1 || scope.var.indexOf(name) &gt; -1;
    scope.lexical.push(name);
    if (this.inModule &amp;&amp; (scope.flags &amp; SCOPE_TOP))
      { delete this.undefinedExports[name]; }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar)
      { redeclared = scope$2.lexical.indexOf(name) &gt; -1; }
    else
      { redeclared = scope$2.lexical.indexOf(name) &gt; -1 || scope$2.var.indexOf(name) &gt; -1; }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i &gt;= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) &gt; -1 &amp;&amp; !((scope$3.flags &amp; SCOPE_SIMPLE_CATCH) &amp;&amp; scope$3.lexical[0] === name) ||
          !this.treatFunctionsAsVarInScope(scope$3) &amp;&amp; scope$3.functions.indexOf(name) &gt; -1) {
        redeclared = true;
        break
      }
      scope$3.var.push(name);
      if (this.inModule &amp;&amp; (scope$3.flags &amp; SCOPE_TOP))
        { delete this.undefinedExports[name]; }
      if (scope$3.flags &amp; SCOPE_VAR) { break }
    }
  }
  if (redeclared) { this.raiseRecoverable(pos, (&quot;Identifier &apos;&quot; + name + &quot;&apos; has already been declared&quot;)); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (this.strict &amp;&amp; this.reservedWordsStrictBind.test(expr.name))
    { this.raiseRecoverable(expr.start, (bindingType ? &quot;Binding &quot; : &quot;Assigning to &quot;) + expr.name + &quot; in
 strict mode&quot;); }
  if (checkClashes) {
    if (has(checkClashes, expr.name))
      { this.raiseRecoverable(expr.start, &quot;Argument name clash&quot;); }
    checkClashes[expr.name] = true;
  }
  if (bindingType !== BIND_NONE &amp;&amp; bindingType !== BIND_OUTSIDE) { this.<span class="apidocCodeKeywordSpan">declareName</
span>(expr.name, bindingType, expr.start); }
  break

case &quot;MemberExpression&quot;:
  if (bindingType) { this.raiseRecoverable(expr.start, &quot;Binding member expression&quot;); }
  break

case &quot;ObjectPattern&quot;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.eat" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.eat">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>eat
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.<span class="apidocCodeKeywordSpan">eat</span>(types.semi) &amp;&amp; !this.insertSemicolon()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.eatContextual" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.eatContextual">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>eatContextual
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.<span class="apidocCodeKeywordSpan">eatContextual</span>(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.enterScope" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.enterScope">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>enterScope
        <span class="apidocSignatureSpan">(flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(flags) {
  this.scopeStack.push(new Scope(flags));
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 &amp;&amp; options.allowHashBang &amp;&amp; this.input.slice(0, 2) === &quot;#!&quot;)
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.<span class="apidocCodeKeywordSpan">enterScope</span>(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },
allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.exitScope" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.exitScope">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>exitScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  this.scopeStack.pop();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      }
      this.expect(types.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.<span class="apidocCodeKeywordSpan">exitScope</span>();
  if (cur) { this.finishNode(cur, &quot;SwitchCase&quot;); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, &quot;SwitchStatement&quot;)
};

pp$1.parseThrowStatement = function(node) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.expect" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.expect">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>expect
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(type) {
  this.eat(type) || this.unexpected();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(&quot;do&quot;);
  this.labels.pop();
  this.<span class="apidocCodeKeywordSpan">expect</span>(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion &gt;= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, &quot;DoWhileStatement&quot;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.expectContextual" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.expectContextual">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>expectContextual
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  this.next();
  // export * from &apos;...&apos;
  if (this.eat(types.star)) {
    this.<span class="apidocCodeKeywordSpan">expectContextual</span>(&quot;from&quot;);
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, &quot;ExportAllDeclaration&quot;)
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, &quot;default&quot;, this.lastTokStart);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.finishNode" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.finishNode">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>finishNode
        <span class="apidocSignatureSpan">(node, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, (&quot;Export &apos;&quot; + name + &quot;&apos; is not defined
&quot;));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.<span class="apidocCodeKeywordSpan">finishNode</span>(node, &quot;Program&quot;)
};

var loopLabel = {kind: &quot;loop&quot;}, switchLabel = {kind: &quot;switch&quot;};

pp$1.isLet = function(context) {
  if (this.options.ecmaVersion &lt; 6 || !this.isContextual(&quot;let&quot;)) { return false }
  skipWhiteSpace.lastIndex = this.pos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.finishNodeAt" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.finishNodeAt">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>finishNodeAt
        <span class="apidocSignatureSpan">(node, type, pos, loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.checkExpressionErrors(refDestructuringErrors, true);
  this.yieldPos = oldYieldPos || this.yieldPos;
  this.awaitPos = oldAwaitPos || this.awaitPos;

  if (exprList.length &gt; 1) {
    val = this.startNodeAt(innerStartPos, innerStartLoc);
    val.expressions = exprList;
    this.<span class="apidocCodeKeywordSpan">finishNodeAt</span>(val, &quot;SequenceExpression&quot;, innerEndPos, innerEndLoc);
  } else {
    val = exprList[0];
  }
} else {
  val = this.parseParenExpression();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.finishOp" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.finishOp">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>finishOp
        <span class="apidocSignatureSpan">(type, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    return this.finishToken(types.dot)
  }
};

pp$9.readToken_slash = function() { // &apos;/&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.<span class="apidocCodeKeywordSpan">finishOp</span>(types.assign, 2) }
  return this.finishOp(types.slash, 1)
};

pp$9.readToken_mult_modulo_exp = function(code) { // &apos;%*&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.finishToken" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.finishToken">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>finishToken
        <span class="apidocSignatureSpan">(type, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

pp$9.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos &gt;= this.input.length) { return this.<span class="apidocCodeKeywordSpan">finishToken</span>(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.fullCharCodeAtPos" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.fullCharCodeAtPos">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>fullCharCodeAtPos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var code = this.input.charCodeAt(this.pos);
  if (code &lt;= 0xd7ff || code &gt;= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code &lt;&lt; 10) + next - 0x35fdc00
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos &gt;= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.<span class="apidocCodeKeywordSpan">fullCharCodeAtPos</span>()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
  // identifiers, so &apos;\&apos; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &apos;\&apos; */)
    { return this.readWord() }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.getToken" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.getToken">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>getToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  this.next();
  return new Token(this)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// When `locations` is on, `loc` properties holding objects with
// `start` and `end` properties in `{line, column}` form (with
// line being 1-based and column 0-based) will be attached to the
// nodes.
locations: false,
// A function can be passed as `onToken` option, which will
// cause Acorn to call that function with object in the same
// format as tokens returned from `tokenizer().<span class="apidocCodeKeywordSpan">getToken</span>()`. Note
// that you are not allowed to call the parser from the
// callbackthat will corrupt its internal state.
onToken: null,
// A function can be passed as `onComment` option, which will
// cause Acorn to call that function with `(block, text, start,
// end)` parameters whenever a comment is skipped. `block` is a
// boolean indicating whether this is a block (`/* */`) comment,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.getTokenFromCode" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.getTokenFromCode">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>getTokenFromCode
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // &apos;.&apos;
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types.parenL)
  case 41: ++this.pos; return this.finishToken(types.parenR)
  case 59: ++this.pos; return this.finishToken(types.semi)
  case 44: ++this.pos; return this.finishToken(types.comma)
  case 91: ++this.pos; return this.finishToken(types.bracketL)
  case 93: ++this.pos; return this.finishToken(types.bracketR)
  case 123: ++this.pos; return this.finishToken(types.braceL)
  case 125: ++this.pos; return this.finishToken(types.braceR)
  case 58: ++this.pos; return this.finishToken(types.colon)
  case 63: ++this.pos; return this.finishToken(types.question)

  case 96: // &apos;`&apos;
    if (this.options.ecmaVersion &lt; 6) { break }
    ++this.pos;
    return this.finishToken(types.backQuote)

  case 48: // &apos;0&apos;
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // &apos;0x&apos;, &apos;0X&apos; - hex number
    if (this.options.ecmaVersion &gt;= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // &apos;0o&apos;, &apos;0O&apos; - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // &apos;0b&apos;, &apos;0B&apos; - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // &apos;&quot;&apos;, &quot;&apos;&quot;
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. &apos;=&apos; (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

  case 47: // &apos;/&apos;
    return this.readToken_slash()

  case 37: case 42: // &apos;%*&apos;
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // &apos;|&amp;&apos;
    return this.readToken_pipe_amp(code)

  case 94: // &apos;^&apos;
    return this.readToken_caret()

  case 43: case 45: // &apos;+-&apos;
    return this.readToken_plus_min(code)

  case 60: case 62: // &apos;&lt;&gt;&apos;
    return this.readToken_lt_gt(code)

  case 61: case 33: // &apos;=!&apos;
    return this.readToken_eq_excl(code)

  case 126: // &apos;~&apos;
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, &quot;Unexpected character &apos;&quot; + codePointToString$1(code) + &quot;&apos;&quot;);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

pp$9.readToken = function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
  // identifiers, so &apos;\&apos; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &apos;\&apos; */)
    { return this.readWord() }

  return this.<span class="apidocCodeKeywordSpan">getTokenFromCode</span>(code)
};

pp$9.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code &lt;= 0xd7ff || code &gt;= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code &lt;&lt; 10) + next - 0x35fdc00
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.inGeneratorContext" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.inGeneratorContext">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>inGeneratorContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  for (var i = this.context.length - 1; i &gt;= 1; i--) {
    var context = this.context[i];
    if (context.token === &quot;function&quot;)
      { return context.generator }
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.exprAllowed = true;
};

types.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; prevType !== types.dot) {
    if (this.value === &quot;of&quot; &amp;&amp; !this.exprAllowed ||
        this.value === &quot;yield&quot; &amp;&amp; this.<span class="apidocCodeKeywordSpan">inGeneratorContext</span>())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

// This file contains Unicode properties extracted from the ECMAScript
// specification. The lists are extracted like so:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.inNonArrowFunction" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.inNonArrowFunction">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>inNonArrowFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inNonArrowFunction () { return (this.currentThisScope().flags &amp; SCOPE_FUNCTION) &gt; 0 }</pre></li>
    <li>example use<pre class="apidocCodePre">...
var meta = this.parseIdent(true);
if (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.eat(types.dot)) {
  node.meta = meta;
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== &quot;target&quot; || containsEsc)
    { this.raiseRecoverable(node.property.start, &quot;The only valid meta property for new is new.target&quot;); }
  if (!this.<span class="apidocCodeKeywordSpan">inNonArrowFunction</span>())
    { this.raiseRecoverable(node.start, &quot;new.target can only be used in functions&quot;); }
  return this.finishNode(node, &quot;MetaProperty&quot;)
}
var startPos = this.start, startLoc = this.startLoc;
node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
if (this.options.ecmaVersion &gt; 10 &amp;&amp; node.callee.type === &quot;Import&quot;) {
  this.raise(node.callee.start, &quot;Cannot use new with import(...)&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.initFunction" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.initFunction">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>initFunction
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  node.id = null;
  if (this.options.ecmaVersion &gt;= 6) { node.generator = node.expression = false; }
  if (this.options.ecmaVersion &gt;= 8) { node.async = false; }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

// Parse a function declaration or literal (depending on the
// `statement &amp; FUNC_STATEMENT`).

// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
  this.<span class="apidocCodeKeywordSpan">initFunction</span>(node);
  if (this.options.ecmaVersion &gt;= 9 || this.options.ecmaVersion &gt;= 6 &amp;&amp; !isAsync) {
    if (this.type === types.star &amp;&amp; (statement &amp; FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types.star);
  }
  if (this.options.ecmaVersion &gt;= 8)
    { node.async = !!isAsync; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.initialContext" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.initialContext">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>initialContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return [types$1.b_stat]
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// Position information for the previous token
this.lastTokEndLoc = this.lastTokStartLoc = null;
this.lastTokStart = this.lastTokEnd = this.pos;

// The context stack is used to superficially track syntactic
// context to predict whether a regular expression is allowed in a
// given position.
this.context = this.<span class="apidocCodeKeywordSpan">initialContext</span>();
this.exprAllowed = true;

// Figure out if it&apos;s a module code.
this.inModule = options.sourceType === &quot;module&quot;;
this.strict = this.inModule || this.strictDirective(this.pos);

// Used to signify the start of a potential arrow function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.insertSemicolon" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.insertSemicolon">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>insertSemicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.eat(types.semi) &amp;&amp; !this.<span class="apidocCodeKeywordSpan">insertSemicolon</span>()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.invalidStringToken" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.invalidStringToken">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>invalidStringToken
        <span class="apidocSignatureSpan">(position, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(position, message) {
  if (this.inTemplateElement &amp;&amp; this.options.ecmaVersion &gt;= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // &apos;{&apos;
    if (this.options.ecmaVersion &lt; 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf(&quot;}&quot;, this.pos) - this.pos);
    ++this.pos;
    if (code &gt; 0x10FFFF) { this.<span class="apidocCodeKeywordSpan">invalidStringToken</span>(codePos, &quot;Code point out of
 bounds&quot;); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

function codePointToString$1(code) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.isAsyncFunction" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.isAsyncFunction">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>isAsyncFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.options.ecmaVersion &lt; 8 || !this.isContextual(&quot;async&quot;))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) &amp;&amp;
    this.input.slice(next, next + 8) === &quot;function&quot; &amp;&amp;
    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// If the statement does not start with a statement keyword or a
// brace, it&apos;s an ExpressionStatement or LabeledStatement. We
// simply start parsing an expression, and afterwards, if the
// next token is a colon and the expression was a simple
// Identifier node, we switch to interpreting it as a label.
    default:
if (this.<span class="apidocCodeKeywordSpan">isAsyncFunction</span>()) {
  if (context) { this.unexpected(); }
  this.next();
  return this.parseFunctionStatement(node, true, !context)
}

var maybeName = this.value, expr = this.parseExpression();
if (starttype === types.name &amp;&amp; expr.type === &quot;Identifier&quot; &amp;&amp; this.eat(types.colon))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.isAsyncProp" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.isAsyncProp">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>isAsyncProp
        <span class="apidocSignatureSpan">(prop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prop) {
  return !prop.computed &amp;&amp; prop.key.type === &quot;Identifier&quot; &amp;&amp; prop.key.name === &quot;async&quot; &amp;&amp;
    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type
.keyword || (this.options.ecmaVersion &gt;= 9 &amp;&amp; this.type === types.star)) &amp;&amp;
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    startLoc = this.startLoc;
  }
  if (!isPattern)
    { isGenerator = this.eat(types.star); }
}
var containsEsc = this.containsEsc;
this.parsePropertyName(prop);
if (!isPattern &amp;&amp; !containsEsc &amp;&amp; this.options.ecmaVersion &gt;= 8 &amp;&amp; !isGenerator &amp;&amp; this.<span
 class="apidocCodeKeywordSpan">isAsyncProp</span>(prop)) {
  isAsync = true;
  isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
  this.parsePropertyName(prop, refDestructuringErrors);
} else {
  isAsync = false;
}
this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.isContextual" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.isContextual">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>isContextual
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(name) {
  return this.type === types.name &amp;&amp; this.value === name &amp;&amp; !this.containsEsc
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp.isContextual = function(name) {
  return this.type === types.name &amp;&amp; this.value === name &amp;&amp; !this.containsEsc
};

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  if (!this.<span class="apidocCodeKeywordSpan">isContextual</span>(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.isDirectiveCandidate" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.isDirectiveCandidate">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>isDirectiveCandidate
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(statement) {
  return (
    statement.type === &quot;ExpressionStatement&quot; &amp;&amp;
    statement.expression.type === &quot;Literal&quot; &amp;&amp;
    typeof statement.expression.value === &quot;string&quot; &amp;&amp;
    // Reject parenthesized strings.
    (this.input[statement.start] === &quot;\&quot;&quot; || this.input[statement.start] === &quot;&apos;&quot;)
  )
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    nodes.push(this.finishNode(node$2, &quot;ImportSpecifier&quot;));
  }
  return nodes
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i &lt; statements.length &amp;&amp; this.<span class="apidocCodeKeywordSpan">isDirectiveCandidate</span>(statements
[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function(statement) {
  return (
    statement.type === &quot;ExpressionStatement&quot; &amp;&amp;
    statement.expression.type === &quot;Literal&quot; &amp;&amp;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.isLet" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.isLet">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>isLet
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(context) {
  if (this.options.ecmaVersion &lt; 6 || !this.isContextual(&quot;let&quot;)) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91) { return true } // &apos;[&apos;
  if (context) { return false }

  if (nextCh === 123) { return true } // &apos;{&apos;
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  // regular expression literal. This is to handle cases like
  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
  // does not help.

  pp$1.parseStatement = function(context, topLevel, exports) {
var starttype = this.type, node = this.startNode(), kind;

if (this.<span class="apidocCodeKeywordSpan">isLet</span>(context)) {
  starttype = types._var;
  kind = &quot;let&quot;;
}

// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.isSimpleAssignTarget" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.isSimpleAssignTarget">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>isSimpleAssignTarget
        <span class="apidocSignatureSpan">(expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(expr) {
  if (expr.type === &quot;ParenthesizedExpression&quot;)
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === &quot;Identifier&quot; || expr.type === &quot;MemberExpression&quot;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    { this.raise(this.yieldPos, &quot;Yield expression cannot be a default value&quot;); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, &quot;Await expression cannot be a default value&quot;); }
};

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === &quot;ParenthesizedExpression&quot;)
    { return this.<span class="apidocCodeKeywordSpan">isSimpleAssignTarget</span>(expr.expression) }
  return expr.type === &quot;Identifier&quot; || expr.type === &quot;MemberExpression&quot;
};

var pp$1 = Parser.prototype;

// ### Statement parsing
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.isSimpleParamList" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.isSimpleParamList">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>isSimpleParamList
        <span class="apidocSignatureSpan">(params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(params) {
  for (var i = 0, list = params; i &lt; list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== &quot;Identifier&quot;) { return false
  } }
  return true
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
var oldStrict = this.strict, useStrict = false;

if (isExpression) {
  node.body = this.parseMaybeAssign();
  node.expression = true;
  this.checkParams(node, false);
} else {
  var nonSimple = this.options.ecmaVersion &gt;= 7 &amp;&amp; !this.<span class="apidocCodeKeywordSpan">isSimpleParamList</span>(
node.params);
  if (!oldStrict || nonSimple) {
    useStrict = this.strictDirective(this.end);
    // If this is a strict mode function, verify that argument names
    // are not repeated, and it does not try to bind the words `eval`
    // or `arguments`.
    if (useStrict &amp;&amp; nonSimple)
      { this.raiseRecoverable(node.start, &quot;Illegal &apos;use strict&apos; directive in function with non-simple parameter list
&quot;); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.next" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.next">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>next
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.<span class="apidocCodeKeywordSpan">next</span>();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.nextToken" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.nextToken">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>nextToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos &gt;= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },
allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.<span class="apidocCodeKeywordSpan">nextToken</span>();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_SUPER) &gt; 0 };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parse" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parse">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        return dflt;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to read pathname
    try {
        return (
            type === &quot;json&quot;
            ? JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(pathname, &quot;utf8&quot;))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
};
local.fsRmrfSync = function (pathname) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseArrowExpression" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseArrowExpression">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseArrowExpression
        <span class="apidocSignatureSpan">(node, params, isAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, params, isAsync) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion &gt;= 8) { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, &quot;ArrowFunctionExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.checkPatternErrors(refDestructuringErrors, false);
  this.checkYieldAwaitInDefaultParams();
  if (this.awaitIdentPos &gt; 0)
    { this.raise(this.awaitIdentPos, &quot;Cannot use &apos;await&apos; as identifier inside an async function&quot;); }
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.<span class="apidocCodeKeywordSpan">parseArrowExpression</span>(this.startNodeAt(startPos, startLoc), exprList, true
)
}
this.checkExpressionErrors(refDestructuringErrors, true);
this.yieldPos = oldYieldPos || this.yieldPos;
this.awaitPos = oldAwaitPos || this.awaitPos;
this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
var node$1 = this.startNodeAt(startPos, startLoc);
node$1.callee = base;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseAwait" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseAwait">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseAwait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, &quot;AwaitExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual(&quot;await&quot;) &amp;&amp; (this.inAsync || (!this.inFunction &amp;&amp; this.options.allowAwaitOutsideFunction
))) {
    expr = this.<span class="apidocCodeKeywordSpan">parseAwait</span>();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseBindingAtom" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseBindingAtom">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseBindingAtom
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.options.ecmaVersion &gt;= 6) {
    switch (this.type) {
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, &quot;ArrayPattern&quot;)

    case types.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
this.next();
node.block = this.parseBlock();
node.handler = null;
if (this.type === types._catch) {
  var clause = this.startNode();
  this.next();
  if (this.eat(types.parenL)) {
    clause.param = this.<span class="apidocCodeKeywordSpan">parseBindingAtom</span>();
    var simple = clause.param.type === &quot;Identifier&quot;;
    this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
    this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
    this.expect(types.parenR);
  } else {
    if (this.options.ecmaVersion &lt; 10) { this.unexpected(); }
    clause.param = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseBindingList" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseBindingList">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseBindingList
        <span class="apidocSignatureSpan">(close, allowEmpty, allowTrailingComma)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this.expect(types.comma); }
    if (allowEmpty &amp;&amp; this.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma &amp;&amp; this.afterTrailingComma(close)) {
      break
    } else if (this.type === types.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
      this.expect(close);
      break
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement &amp; FUNC_STATEMENT) ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot
;)
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.<span class="apidocCodeKeywordSpan">parseBindingList</span>(types.parenR, false, this.options.ecmaVersion &
gt;= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseBindingListItem" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseBindingListItem">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseBindingListItem
        <span class="apidocSignatureSpan">(param)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(param) {
  return param
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
else { this.expect(types.comma); }
if (allowEmpty &amp;&amp; this.type === types.comma) {
  elts.push(null);
} else if (allowTrailingComma &amp;&amp; this.afterTrailingComma(close)) {
  break
} else if (this.type === types.ellipsis) {
  var rest = this.parseRestBinding();
  this.<span class="apidocCodeKeywordSpan">parseBindingListItem</span>(rest);
  elts.push(rest);
  if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
  this.expect(close);
  break
} else {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseBlock" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseBlock">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseBlock
        <span class="apidocSignatureSpan">(createNewLexicalScope, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(createNewLexicalScope, node) {
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (!this.eat(types.braceR)) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, &quot;BlockStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.parseWithStatement(node)
case types.braceL: return this.<span class="apidocCodeKeywordSpan">parseBlock</span>(true, node)
case types.semi: return this.parseEmptyStatement(node)
case types._export:
case types._import:
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseBreakContinueStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseBreakContinueStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseBreakContinueStatement
        <span class="apidocSignatureSpan">(node, keyword)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, keyword) {
  var isBreak = keyword === &quot;break&quot;;
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i &lt; this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null &amp;&amp; (isBreak || lab.kind === &quot;loop&quot;)) { break }
      if (node.label &amp;&amp; isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, &quot;Unsyntactic &quot; + keyword); }
  return this.finishNode(node, isBreak ? &quot;BreakStatement&quot; : &quot;ContinueStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
}

// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.

switch (starttype) {
case types._break: case types._continue: return this.<span class="apidocCodeKeywordSpan">parseBreakContinueStatement</span>(node
, starttype.keyword)
case types._debugger: return this.parseDebuggerStatement(node)
case types._do: return this.parseDoStatement(node)
case types._for: return this.parseForStatement(node)
case types._function:
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseClass" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseClass">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseClass
        <span class="apidocSignatureSpan">(node, isStatement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isStatement) {
  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === &quot;MethodDefinition&quot; &amp;&amp; element.kind === &quot;constructor&quot;) {
        if (hadConstructor) { this.raise(element.start, &quot;Duplicate constructor in the same class&quot;); }
        hadConstructor = true;
      }
    }
  }
  node.body = this.finishNode(classBody, &quot;ClassBody&quot;);
  this.strict = oldStrict;
  return this.finishNode(node, isStatement ? &quot;ClassDeclaration&quot; : &quot;ClassExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.<span class="apidocCodeKeywordSpan">parseClass</span>(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseClassElement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseClassElement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseClassElement
        <span class="apidocSignatureSpan">(constructorAllowsSuper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(constructorAllowsSuper) {
  var this$1 = this;

  if (this.eat(types.semi)) { return null }

  var method = this.startNode();
  var tryContextual = function (k, noLineBreak) {
    if ( noLineBreak === void 0 ) noLineBreak = false;

    var start = this$1.start, startLoc = this$1.startLoc;
    if (!this$1.eatContextual(k)) { return false }
    if (this$1.type !== types.parenL &amp;&amp; (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
    if (method.key) { this$1.unexpected(); }
    method.computed = false;
    method.key = this$1.startNodeAt(start, startLoc);
    method.key.name = k;
    this$1.finishNode(method.key, &quot;Identifier&quot;);
    return false
  };

  method.kind = &quot;method&quot;;
  method.static = tryContextual(&quot;static&quot;);
  var isGenerator = this.eat(types.star);
  var isAsync = false;
  if (!isGenerator) {
    if (this.options.ecmaVersion &gt;= 8 &amp;&amp; tryContextual(&quot;async&quot;, true)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
    } else if (tryContextual(&quot;get&quot;)) {
      method.kind = &quot;get&quot;;
    } else if (tryContextual(&quot;set&quot;)) {
      method.kind = &quot;set&quot;;
    }
  }
  if (!method.key) { this.parsePropertyName(method); }
  var key = method.key;
  var allowsDirectSuper = false;
  if (!method.computed &amp;&amp; !method.static &amp;&amp; (key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;constructor&quot; ||
      key.type === &quot;Literal&quot; &amp;&amp; key.value === &quot;constructor&quot;)) {
    if (method.kind !== &quot;method&quot;) { this.raise(key.start, &quot;Constructor can&apos;t have get/set modifier&quot;); }
    if (isGenerator) { this.raise(key.start, &quot;Constructor can&apos;t be a generator&quot;); }
    if (isAsync) { this.raise(key.start, &quot;Constructor can&apos;t be an async method&quot;); }
    method.kind = &quot;constructor&quot;;
    allowsDirectSuper = constructorAllowsSuper;
  } else if (method.static &amp;&amp; key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;prototype&quot;) {
    this.raise(key.start, &quot;Classes may not have a static property named prototype&quot;);
  }
  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === &quot;get&quot; &amp;&amp; method.value.params.length !== 0)
    { this.raiseRecoverable(method.value.start, &quot;getter should have no params&quot;); }
  if (method.kind === &quot;set&quot; &amp;&amp; method.value.params.length !== 1)
    { this.raiseRecoverable(method.value.start, &quot;setter should have exactly one param&quot;); }
  if (method.kind === &quot;set&quot; &amp;&amp; method.value.params[0].type === &quot;RestElement&quot;)
    { this.raiseRecoverable(method.value.params[0].start, &quot;Setter cannot use rest params&quot;); }
  return method
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
this.parseClassId(node, isStatement);
this.parseClassSuper(node);
var classBody = this.startNode();
var hadConstructor = false;
classBody.body = [];
this.expect(types.braceL);
while (!this.eat(types.braceR)) {
  var element = this.<span class="apidocCodeKeywordSpan">parseClassElement</span>(node.superClass !== null);
  if (element) {
    classBody.body.push(element);
    if (element.type === &quot;MethodDefinition&quot; &amp;&amp; element.kind === &quot;constructor&quot;) {
      if (hadConstructor) { this.raise(element.start, &quot;Duplicate constructor in the same class&quot;); }
      hadConstructor = true;
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseClassId" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseClassId">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseClassId
        <span class="apidocSignatureSpan">(node, isStatement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isStatement) {
  if (this.type === types.name) {
    node.id = this.parseIdent();
    if (isStatement)
      { this.checkLVal(node.id, BIND_LEXICAL, false); }
  } else {
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
this.next();

// ecma-262 14.6 Class Definitions
// A class definition is always strict mode code.
var oldStrict = this.strict;
this.strict = true;

this.<span class="apidocCodeKeywordSpan">parseClassId</span>(node, isStatement);
this.parseClassSuper(node);
var classBody = this.startNode();
var hadConstructor = false;
classBody.body = [];
this.expect(types.braceL);
while (!this.eat(types.braceR)) {
  var element = this.parseClassElement(node.superClass !== null);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseClassMethod" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseClassMethod">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseClassMethod
        <span class="apidocSignatureSpan">(method, isGenerator, isAsync, allowsDirectSuper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(method, isGenerator, isAsync, allowsDirectSuper) {
  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  return this.finishNode(method, &quot;MethodDefinition&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (isGenerator) { this.raise(key.start, &quot;Constructor can&apos;t be a generator&quot;); }
  if (isAsync) { this.raise(key.start, &quot;Constructor can&apos;t be an async method&quot;); }
  method.kind = &quot;constructor&quot;;
  allowsDirectSuper = constructorAllowsSuper;
} else if (method.static &amp;&amp; key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;prototype&quot;) {
  this.raise(key.start, &quot;Classes may not have a static property named prototype&quot;);
}
this.<span class="apidocCodeKeywordSpan">parseClassMethod</span>(method, isGenerator, isAsync, allowsDirectSuper);
if (method.kind === &quot;get&quot; &amp;&amp; method.value.params.length !== 0)
  { this.raiseRecoverable(method.value.start, &quot;getter should have no params&quot;); }
if (method.kind === &quot;set&quot; &amp;&amp; method.value.params.length !== 1)
  { this.raiseRecoverable(method.value.start, &quot;setter should have exactly one param&quot;); }
if (method.kind === &quot;set&quot; &amp;&amp; method.value.params[0].type === &quot;RestElement&quot;)
  { this.raiseRecoverable(method.value.params[0].start, &quot;Setter cannot use rest params&quot;); }
return method
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseClassSuper" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseClassSuper">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseClassSuper
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// ecma-262 14.6 Class Definitions
// A class definition is always strict mode code.
var oldStrict = this.strict;
this.strict = true;

this.parseClassId(node, isStatement);
this.<span class="apidocCodeKeywordSpan">parseClassSuper</span>(node);
var classBody = this.startNode();
var hadConstructor = false;
classBody.body = [];
this.expect(types.braceL);
while (!this.eat(types.braceR)) {
  var element = this.parseClassElement(node.superClass !== null);
  if (element) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseDebuggerStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseDebuggerStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseDebuggerStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, &quot;DebuggerStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.

switch (starttype) {
case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
case types._debugger: return this.<span class="apidocCodeKeywordSpan">parseDebuggerStatement</span>(node)
case types._do: return this.parseDoStatement(node)
case types._for: return this.parseForStatement(node)
case types._function:
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseDoStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseDoStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseDoStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(&quot;do&quot;);
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion &gt;= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, &quot;DoWhileStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.

switch (starttype) {
case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
case types._debugger: return this.parseDebuggerStatement(node)
case types._do: return this.<span class="apidocCodeKeywordSpan">parseDoStatement</span>(node)
case types._for: return this.parseForStatement(node)
case types._function:
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseDynamicImport" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseDynamicImport">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseDynamicImport
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var node = this.startNode();
  this.next();
  if (this.type !== types.parenL) {
    this.unexpected();
  }
  return this.finishNode(node, &quot;Import&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return this.parseNew()

case types.backQuote:
  return this.parseTemplate()

case types._import:
  if (this.options.ecmaVersion &gt; 10) {
    return this.<span class="apidocCodeKeywordSpan">parseDynamicImport</span>()
  } else {
    return this.unexpected()
  }

default:
  this.unexpected();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseEmptyStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseEmptyStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseEmptyStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  return this.finishNode(node, &quot;EmptyStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.parseWithStatement(node)
case types.braceL: return this.parseBlock(true, node)
case types.semi: return this.<span class="apidocCodeKeywordSpan">parseEmptyStatement</span>(node)
case types._export:
case types._import:
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    if (nextCh === 40) // &apos;(&apos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExport" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExport">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExport
        <span class="apidocSignatureSpan">(node, exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, exports) {
  this.next();
  // export * from &apos;...&apos;
  if (this.eat(types.star)) {
    this.expectContextual(&quot;from&quot;);
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, &quot;ExportAllDeclaration&quot;)
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, &quot;default&quot;, this.lastTokStart);
    var isAsync;
    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, &quot;nullableID&quot;);
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, &quot;ExportDefaultDeclaration&quot;)
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(null);
    if (node.declaration.type === &quot;VariableDeclaration&quot;)
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from &apos;...&apos;]
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual(&quot;from&quot;)) {
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list = node.specifiers; i &lt; list.length; i += 1) {
        // check for keywords used as local names
        var spec = list[i];

        this.checkUnreserved(spec.local);
        // check if export is defined
        this.checkLocalExport(spec.local);
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, &quot;ExportNamedDeclaration&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

  if (!this.options.allowImportExportEverywhere) {
    if (!topLevel)
      { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may only appear at the top level&quot;); }
    if (!this.inModule)
      { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may appear only with &apos;sourceType: module&apos
;&quot;); }
  }
  return starttype === types._import ? this.parseImport(node) : this.<span class="apidocCodeKeywordSpan">parseExport</span>(node
, exports)

  // If the statement does not start with a statement keyword or a
  // brace, it&apos;s an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExportSpecifiers" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExportSpecifiers">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExportSpecifiers
        <span class="apidocSignatureSpan">(exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(exports) {
  var nodes = [], first = true;
  // export { x, y as z } [from &apos;...&apos;]
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node = this.startNode();
    node.local = this.parseIdent(true);
    node.exported = this.eatContextual(&quot;as&quot;) ? this.parseIdent(true) : node.local;
    this.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this.finishNode(node, &quot;ExportSpecifier&quot;));
  }
  return nodes
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    { this.checkVariableExport(exports, node.declaration.declarations); }
  else
    { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
  node.specifiers = [];
  node.source = null;
} else { // export { x, y as z } [from &apos;...&apos;]
  node.declaration = null;
  node.specifiers = this.<span class="apidocCodeKeywordSpan">parseExportSpecifiers</span>(exports);
  if (this.eatContextual(&quot;from&quot;)) {
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
  } else {
    for (var i = 0, list = node.specifiers; i &lt; list.length; i += 1) {
      // check for keywords used as local names
      var spec = list[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExprAtom" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExprAtom">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExprAtom
        <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types.slash) { this.readRegexp(); }

  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types._super:
    if (!this.allowSuper)
      { this.raise(this.start, &quot;&apos;super&apos; keyword outside a method&quot;); }
    node = this.startNode();
    this.next();
    if (this.type === types.parenL &amp;&amp; !this.allowDirectSuper)
      { this.raise(node.start, &quot;super() call outside constructor of a subclass&quot;); }
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super Arguments
    if (this.type !== types.dot &amp;&amp; this.type !== types.bracketL &amp;&amp; this.type !== types.parenL)
      { this.unexpected(); }
    return this.finishNode(node, &quot;Super&quot;)

  case types._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, &quot;ThisExpression&quot;)

  case types.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(false);
    if (this.options.ecmaVersion &gt;= 8 &amp;&amp; !containsEsc &amp;&amp; id.name === &quot;async&quot; &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types._function
))
      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
    if (canBeArrow &amp;&amp; !this.canInsertSemicolon()) {
      if (this.eat(types.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
      if (this.options.ecmaVersion &gt;= 8 &amp;&amp; id.name === &quot;async&quot; &amp;&amp; this.type === types.name &amp;&amp; !containsEsc) {
        id = this.parseIdent(false);
        if (this.canInsertSemicolon() || !this.eat(types.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case types.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types.num: case types.string:
    return this.parseLiteral(this.value)

  case types._null: case types._true: case types._false:
    node = this.startNode();
    node.value = this.type === types._null ? null : this.type === types._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, &quot;Literal&quot;)

  case types.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign &lt; 0 &amp;&amp; !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind &lt; 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, &quot;ArrayExpression&quot;)

  case types.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case types._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, 0)

  case types._class:
    return this.parseClass(this.startNode(), false)

  case types._new:
    return this.parseNew()

  case types.backQuote:
    return this.parseTemplate()

  case types._import:
    if (this.options.ecmaVersion &gt; 10) {
      return this.parseDynamicImport()
    } else {
      return this.unexpected()
    }

  default:
    this.unexpected();
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

  pp$1.parseExport = function(node, exports) {
this.next();
// export * from &apos;...&apos;
if (this.eat(types.star)) {
  this.expectContextual(&quot;from&quot;);
  if (this.type !== types.string) { this.unexpected(); }
  node.source = this.<span class="apidocCodeKeywordSpan">parseExprAtom</span>();
  this.semicolon();
  return this.finishNode(node, &quot;ExportAllDeclaration&quot;)
}
if (this.eat(types._default)) { // export default ...
  this.checkExport(exports, &quot;default&quot;, this.lastTokStart);
  var isAsync;
  if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExprList" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExprList">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExprList
        <span class="apidocSignatureSpan">(close, allowTrailingComma, allowEmpty, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types.comma);
      if (allowTrailingComma &amp;&amp; this.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty &amp;&amp; this.type === types.comma)
      { elt = null; }
    else if (this.type === types.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors &amp;&amp; this.type === types.comma &amp;&amp; refDestructuringErrors.trailingComma &lt; 0)
        { refDestructuringErrors.trailingComma = this.start; }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (computed) { this.expect(types.bracketR); }
  base = this.finishNode(node, &quot;MemberExpression&quot;);
} else if (!noCalls &amp;&amp; this.eat(types.parenL)) {
  var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos
 = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  var exprList = this.<span class="apidocCodeKeywordSpan">parseExprList</span>(types.parenR, this.options.ecmaVersion &gt;= 8 &amp
;&amp; base.type !== &quot;Import&quot;, false, refDestructuringErrors);
  if (maybeAsyncArrow &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types.arrow)) {
    this.checkPatternErrors(refDestructuringErrors, false);
    this.checkYieldAwaitInDefaultParams();
    if (this.awaitIdentPos &gt; 0)
      { this.raise(this.awaitIdentPos, &quot;Cannot use &apos;await&apos; as identifier inside an async function&quot;); }
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExprOp" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExprOp">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExprOp
        <span class="apidocSignatureSpan">(left, leftStartPos, leftStartLoc, minPrec, noIn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null &amp;&amp; (!noIn || this.type !== types._in)) {
    if (prec &gt; minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos &amp;&amp; expr.type === &quot;ArrowFunctionExpression&quot; ? expr : this.<span class="apidocCodeKeywordSpan
">parseExprOp</span>(expr, startPos, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExprOps" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExprOps">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExprOps
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos &amp;&amp; expr.type === &quot;ArrowFunctionExpression&quot; ? expr : this.parseExprOp(expr, startPos, startLoc, -
1, noIn)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.<span class="apidocCodeKeywordSpan">parseExprOps</span>(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExprSubscripts" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExprSubscripts">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExprSubscripts
        <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === &quot;ArrowFunctionExpression&quot; &amp;&amp; this.input.slice(this.lastTokStart, this.lastTokEnd) !== &quot;)&quot;;
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors &amp;&amp; result.type === &quot;MemberExpression&quot;) {
    if (refDestructuringErrors.parenthesizedAssign &gt;= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind &gt;= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
};

pp$1.parseClassSuper = function(node) {
  node.superClass = this.eat(types._extends) ? this.<span class="apidocCodeKeywordSpan">parseExprSubscripts</span>() : null;
};

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  this.next();
  // export * from &apos;...&apos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExpression" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExpression">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExpression
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
    return this.finishNode(node, &quot;SequenceExpression&quot;)
  }
  return expr
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
Parser.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.<span class="apidocCodeKeywordSpan">parseExpression</span>()
};

Parser.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser.prototype, prototypeAccessors );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExpressionStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseExpressionStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseExpressionStatement
        <span class="apidocSignatureSpan">(node, expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, &quot;ExpressionStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    case types._export:
    case types._import:
if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 40) // &apos;(&apos;
    { return this.<span class="apidocCodeKeywordSpan">parseExpressionStatement</span>(node, this.parseExpression()) }
}

if (!this.options.allowImportExportEverywhere) {
  if (!topLevel)
    { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may only appear at the top level&quot;); }
  if (!this.inModule)
    { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may appear only with &apos;sourceType: module&apos;&
quot;); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseFor" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseFor">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseFor
        <span class="apidocSignatureSpan">(node, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement(&quot;for&quot;);
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, &quot;ForStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
this.next();
var awaitAt = (this.options.ecmaVersion &gt;= 9 &amp;&amp; (this.inAsync || (!this.inFunction &amp;&amp; this.options.allowAwaitOutsideFunction
)) &amp;&amp; this.eatContextual(&quot;await&quot;)) ? this.lastTokStart : -1;
this.labels.push(loopLabel);
this.enterScope(0);
this.expect(types.parenL);
if (this.type === types.semi) {
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.<span class="apidocCodeKeywordSpan">parseFor</span>(node, null)
}
var isLet = this.isLet();
if (this.type === types._var || this.type === types._const || isLet) {
  var init$1 = this.startNode(), kind = isLet ? &quot;let&quot; : this.value;
  this.next();
  this.parseVar(init$1, true, kind);
  this.finishNode(init$1, &quot;VariableDeclaration&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseForIn" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseForIn">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseForIn
        <span class="apidocSignatureSpan">(node, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, init) {
  var isForIn = this.type === types._in;
  this.next();

  if (
    init.type === &quot;VariableDeclaration&quot; &amp;&amp;
    init.declarations[0].init != null &amp;&amp;
    (
      !isForIn ||
      this.options.ecmaVersion &lt; 8 ||
      this.strict ||
      init.kind !== &quot;var&quot; ||
      init.declarations[0].id.type !== &quot;Identifier&quot;
    )
  ) {
    this.raise(
      init.start,
      ((isForIn ? &quot;for-in&quot; : &quot;for-of&quot;) + &quot; loop variable declaration may not have an initializer&quot;)
    );
  } else if (init.type === &quot;AssignmentPattern&quot;) {
    this.raise(init.start, &quot;Invalid left-hand side in for-loop&quot;);
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  node.body = this.parseStatement(&quot;for&quot;);
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? &quot;ForInStatement&quot; : &quot;ForOfStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.finishNode(init$1, &quot;VariableDeclaration&quot;);
  if ((this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) &amp;&amp; init
$1.declarations.length === 1) {
    if (this.options.ecmaVersion &gt;= 9) {
      if (this.type === types._in) {
        if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt &gt; -1; }
    }
    return this.<span class="apidocCodeKeywordSpan">parseForIn</span>(node, init$1)
  }
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init$1)
}
var refDestructuringErrors = new DestructuringErrors;
var init = this.parseExpression(true, refDestructuringErrors);
if (this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseForStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseForStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseForStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion &gt;= 9 &amp;&amp; (this.inAsync || (!this.inFunction &amp;&amp; this.options.allowAwaitOutsideFunction)) &amp;&amp;
this.eatContextual(&quot;await&quot;)) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types.parenL);
  if (this.type === types.semi) {
    if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? &quot;let&quot; : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, &quot;VariableDeclaration&quot;);
    if ((this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) &amp;&amp; init$1.declarations.length ===
1) {
      if (this.options.ecmaVersion &gt;= 9) {
        if (this.type === types._in) {
          if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt &gt; -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) {
    if (this.options.ecmaVersion &gt;= 9) {
      if (this.type === types._in) {
        if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt &gt; -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// start with. Many are trivial to parse, some require a bit of
// complexity.

switch (starttype) {
case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
case types._debugger: return this.parseDebuggerStatement(node)
case types._do: return this.parseDoStatement(node)
case types._for: return this.<span class="apidocCodeKeywordSpan">parseForStatement</span>(node)
case types._function:
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
case types._class:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseFunction" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseFunction">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseFunction
        <span class="apidocSignatureSpan">(node, statement, allowExpressionBody, isAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, statement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion &gt;= 9 || this.options.ecmaVersion &gt;= 6 &amp;&amp; !isAsync) {
    if (this.type === types.star &amp;&amp; (statement &amp; FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types.star);
  }
  if (this.options.ecmaVersion &gt;= 8)
    { node.async = !!isAsync; }

  if (statement &amp; FUNC_STATEMENT) {
    node.id = (statement &amp; FUNC_NULLABLE_ID) &amp;&amp; this.type !== types.name ? null : this.parseIdent();
    if (node.id &amp;&amp; !(statement &amp; FUNC_HANGING_STATEMENT))
      // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL
 : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement &amp; FUNC_STATEMENT))
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement &amp; FUNC_STATEMENT) ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  }
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.<span class="apidocCodeKeywordSpan">parseFunction</span>(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT
), false, isAsync)
};

pp$1.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement(&quot;if&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseFunctionBody" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseFunctionBody">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseFunctionBody
        <span class="apidocSignatureSpan">(node, isArrowFunction, isMethod)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isArrowFunction, isMethod) {
  var isExpression = isArrowFunction &amp;&amp; this.type !== types.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion &gt;= 7 &amp;&amp; !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict &amp;&amp; nonSimple)
        { this.raiseRecoverable(node.start, &quot;Illegal &apos;use strict&apos; directive in function with non-simple parameter list&quot;); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict &amp;&amp; !useStrict &amp;&amp; !isArrowFunction &amp;&amp; !isMethod &amp;&amp; this.isSimpleParamList(node.params));
    node.body = this.parseBlock(false);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();

  // Ensure the function name isn&apos;t a forbidden identifier in strict mode, e.g. &apos;eval&apos;
  if (this.strict &amp;&amp; node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
  this.strict = oldStrict;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement &amp; FUNC_STATEMENT))
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.<span class="apidocCodeKeywordSpan">parseFunctionBody</span>(node, allowExpressionBody, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement &amp; FUNC_STATEMENT) ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot
;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseFunctionParams" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseFunctionParams">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseFunctionParams
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion &gt;= 8);
  this.checkYieldAwaitInDefaultParams();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement &amp; FUNC_STATEMENT))
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.<span class="apidocCodeKeywordSpan">parseFunctionParams</span>(node);
  this.parseFunctionBody(node, allowExpressionBody, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement &amp; FUNC_STATEMENT) ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot
;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseFunctionStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseFunctionStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseFunctionStatement
        <span class="apidocSignatureSpan">(node, isAsync, declarationPosition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case types._do: return this.parseDoStatement(node)
case types._for: return this.parseForStatement(node)
case types._function:
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.<span class="apidocCodeKeywordSpan">parseFunctionStatement</span>(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseIdent" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseIdent">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseIdent
        <span class="apidocSignatureSpan">(liberal, isBinding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(liberal, isBinding) {
  var node = this.startNode();
  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === &quot;class&quot; || node.name === &quot;function&quot;) &amp;&amp;
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, &quot;Identifier&quot;);
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === &quot;await&quot; &amp;&amp; !this.awaitIdentPos)
      { this.awaitIdentPos = node.start; }
  }
  return node
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

  pp$1.parseBreakContinueStatement = function(node, keyword) {
var isBreak = keyword === &quot;break&quot;;
this.next();
if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
else if (this.type !== types.name) { this.unexpected(); }
else {
  node.label = this.<span class="apidocCodeKeywordSpan">parseIdent</span>();
  this.semicolon();
}

// Verify that there is an actual destination to break or
// continue to.
var i = 0;
for (; i &lt; this.labels.length; ++i) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseIfStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseIfStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseIfStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement(&quot;if&quot;);
  node.alternate = this.eat(types._else) ? this.parseStatement(&quot;if&quot;) : null;
  return this.finishNode(node, &quot;IfStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.<span class="apidocCodeKeywordSpan">parseIfStatement</span>(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseImport" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseImport">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseImport
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  // import &apos;...&apos;
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual(&quot;from&quot;);
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, &quot;ImportDeclaration&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

  if (!this.options.allowImportExportEverywhere) {
    if (!topLevel)
      { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may only appear at the top level&quot;); }
    if (!this.inModule)
      { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may appear only with &apos;sourceType: module&apos
;&quot;); }
  }
  return starttype === types._import ? this.<span class="apidocCodeKeywordSpan">parseImport</span>(node) : this.parseExport(node
, exports)

  // If the statement does not start with a statement keyword or a
  // brace, it&apos;s an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseImportSpecifiers" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseImportSpecifiers">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseImportSpecifiers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var nodes = [], first = true;
  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from &apos;...&apos;
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node, &quot;ImportDefaultSpecifier&quot;));
    if (!this.eat(types.comma)) { return nodes }
  }
  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual(&quot;as&quot;);
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$1, &quot;ImportNamespaceSpecifier&quot;));
    return nodes
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node$2 = this.startNode();
    node$2.imported = this.parseIdent(true);
    if (this.eatContextual(&quot;as&quot;)) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLVal(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, &quot;ImportSpecifier&quot;));
  }
  return nodes
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp$1.parseImport = function(node) {
  this.next();
  // import &apos;...&apos;
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.<span class="apidocCodeKeywordSpan">parseImportSpecifiers</span>();
    this.expectContextual(&quot;from&quot;);
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, &quot;ImportDeclaration&quot;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseLabeledStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseLabeledStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseLabeledStatement
        <span class="apidocSignatureSpan">(node, maybeName, expr, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 &lt; list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this.raise(expr.start, &quot;Label &apos;&quot; + maybeName + &quot;&apos; is already declared&quot;);
  } }
  var kind = this.type.isLoop ? &quot;loop&quot; : this.type === types._switch ? &quot;switch&quot; : null;
  for (var i = this.labels.length - 1; i &gt;= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf(&quot;label&quot;) === -1 ? context + &quot;label&quot; : context : &quot;label&quot;);
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, &quot;LabeledStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name &amp;&amp; expr.type === &quot;Identifier&quot; &amp;&amp; this.eat(types.colon))
      { return this.<span class="apidocCodeKeywordSpan">parseLabeledStatement</span>(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$1.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === &quot;break&quot;;
  this.next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseLiteral" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseLiteral">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseLiteral
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
  this.next();
  return this.finishNode(node, &quot;Literal&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
    }
  }
  return id

case types.regexp:
  var value = this.value;
  node = this.<span class="apidocCodeKeywordSpan">parseLiteral</span>(value.value);
  node.regex = {pattern: value.pattern, flags: value.flags};
  return node

case types.num: case types.string:
  return this.parseLiteral(this.value)

case types._null: case types._true: case types._false:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseMaybeAssign" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseMaybeAssign">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseMaybeAssign
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors, afterLeftParse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(noIn, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual(&quot;yield&quot;)) {
    if (this.inGenerator) { return this.parseYield(noIn) }
    // The tokenizer will assume an expression is allowed after
    // `yield`, but this isn&apos;t that kind of yield
    else { this.exprAllowed = false; }
  }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldShorthandAssign = refDestructuringErrors.shorthandAssign;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -
1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types.parenL || this.type === types.name)
    { this.potentialArrowAt = this.start; }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, &quot;AssignmentExpression&quot;)
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign &gt; -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma &gt; -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  if (oldShorthandAssign &gt; -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }
  return left
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      init.start,
      ((isForIn ? &quot;for-in&quot; : &quot;for-of&quot;) + &quot; loop variable declaration may not have an initializer&quot;)
    );
  } else if (init.type === &quot;AssignmentPattern&quot;) {
    this.raise(init.start, &quot;Invalid left-hand side in for-loop&quot;);
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.<span class="apidocCodeKeywordSpan">parseMaybeAssign</span>();
  this.expect(types.parenR);
  node.body = this.parseStatement(&quot;for&quot;);
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? &quot;ForInStatement&quot; : &quot;ForOfStatement&quot;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseMaybeConditional" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseMaybeConditional">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseMaybeConditional
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, &quot;ConditionalExpression&quot;)
  }
  return expr
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  refDestructuringErrors = new DestructuringErrors;
  ownDestructuringErrors = true;
}

var startPos = this.start, startLoc = this.startLoc;
if (this.type === types.parenL || this.type === types.name)
  { this.potentialArrowAt = this.start; }
var left = this.<span class="apidocCodeKeywordSpan">parseMaybeConditional</span>(noIn, refDestructuringErrors);
if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
if (this.type.isAssign) {
  var node = this.startNodeAt(startPos, startLoc);
  node.operator = this.value;
  node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
  if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
  refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseMaybeDefault" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseMaybeDefault">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseMaybeDefault
        <span class="apidocSignatureSpan">(startPos, startLoc, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion &lt; 6 || !this.eat(types.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, &quot;AssignmentPattern&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
      this.expect(close);
      break
    } else {
      var elem = this.<span class="apidocCodeKeywordSpan">parseMaybeDefault</span>(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseMaybeUnary" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseMaybeUnary">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseMaybeUnary
        <span class="apidocSignatureSpan">(refDestructuringErrors, sawUnary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors, sawUnary) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual(&quot;await&quot;) &amp;&amp; (this.inAsync || (!this.inFunction &amp;&amp; this.options.allowAwaitOutsideFunction))) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLVal(node.argument); }
    else if (this.strict &amp;&amp; node.operator === &quot;delete&quot; &amp;&amp;
             node.argument.type === &quot;Identifier&quot;)
      { this.raiseRecoverable(node.start, &quot;Deleting local variable in strict mode&quot;); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? &quot;UpdateExpression&quot; : &quot;UnaryExpression&quot;);
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix &amp;&amp; !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node$1, &quot;UpdateExpression&quot;);
    }
  }

  if (!sawUnary &amp;&amp; this.eat(types.starstar))
    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), &quot;**&quot;, false) }
  else
    { return expr }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return expr
};

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.<span class="apidocCodeKeywordSpan">parseMaybeUnary</span>(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos &amp;&amp; expr.type === &quot;ArrowFunctionExpression&quot; ? expr : this.parseExprOp(expr, startPos
, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseMethod" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseMethod">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseMethod
        <span class="apidocSignatureSpan">(isGenerator, isAsync, allowDirectSuper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.initFunction(node);
  if (this.options.ecmaVersion &gt;= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion &gt;= 8)
    { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion &gt;= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, &quot;FunctionExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    { this.raiseRecoverable(method.value.start, &quot;setter should have exactly one param&quot;); }
  if (method.kind === &quot;set&quot; &amp;&amp; method.value.params[0].type === &quot;RestElement&quot;)
    { this.raiseRecoverable(method.value.params[0].start, &quot;Setter cannot use rest params&quot;); }
  return method
};

pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  method.value = this.<span class="apidocCodeKeywordSpan">parseMethod</span>(isGenerator, isAsync, allowsDirectSuper);
  return this.finishNode(method, &quot;MethodDefinition&quot;)
};

pp$1.parseClassId = function(node, isStatement) {
  if (this.type === types.name) {
    node.id = this.parseIdent();
    if (isStatement)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseNew" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseNew">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseNew
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.eat(types.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== &quot;target&quot; || containsEsc)
      { this.raiseRecoverable(node.property.start, &quot;The only valid meta property for new is new.target&quot;); }
    if (!this.inNonArrowFunction())
      { this.raiseRecoverable(node.start, &quot;new.target can only be used in functions&quot;); }
    return this.finishNode(node, &quot;MetaProperty&quot;)
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; node.callee.type === &quot;Import&quot;) {
    this.raise(node.callee.start, &quot;Cannot use new with import(...)&quot;);
  }
  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion &gt;= 8 &amp;&amp; node.callee.type
 !== &quot;Import&quot;, false); }
  else { node.arguments = empty$1; }
  return this.finishNode(node, &quot;NewExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.next();
  return this.parseFunction(node, 0)

case types._class:
  return this.parseClass(this.startNode(), false)

case types._new:
  return this.<span class="apidocCodeKeywordSpan">parseNew</span>()

case types.backQuote:
  return this.parseTemplate()

case types._import:
  if (this.options.ecmaVersion &gt; 10) {
    return this.parseDynamicImport()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseObj" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseObj">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseObj
        <span class="apidocSignatureSpan">(isPattern, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? &quot;ObjectPattern&quot; : &quot;ObjectExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, &quot;ArrayPattern&quot;)

    case types.braceL:
      return this.<span class="apidocCodeKeywordSpan">parseObj</span>(true)
    }
  }
  return this.parseIdent()
};

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseParenAndDistinguishExpression" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseParenAndDistinguishExpression">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseParenAndDistinguishExpression
        <span class="apidocSignatureSpan">(canBeArrow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(canBeArrow) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion &gt;= 8;
  if (this.options.ecmaVersion &gt;= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    // Do not save awaitIdentPos to allow checking awaits nested in parameters
    while (this.type !== types.parenR) {
      first ? first = false : this.expect(types.comma);
      if (allowTrailingComma &amp;&amp; this.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this.type === types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
        break
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length &gt; 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, &quot;SequenceExpression&quot;, innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, &quot;ParenthesizedExpression&quot;)
  } else {
    return val
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  node = this.startNode();
  node.value = this.type === types._null ? null : this.type === types._true;
  node.raw = this.type.keyword;
  this.next();
  return this.finishNode(node, &quot;Literal&quot;)

case types.parenL:
  var start = this.start, expr = this.<span class="apidocCodeKeywordSpan">parseParenAndDistinguishExpression</span>(canBeArrow);
  if (refDestructuringErrors) {
    if (refDestructuringErrors.parenthesizedAssign &lt; 0 &amp;&amp; !this.isSimpleAssignTarget(expr))
      { refDestructuringErrors.parenthesizedAssign = start; }
    if (refDestructuringErrors.parenthesizedBind &lt; 0)
      { refDestructuringErrors.parenthesizedBind = start; }
  }
  return expr
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseParenArrowList" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseParenArrowList">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseParenArrowList
        <span class="apidocSignatureSpan">(startPos, startLoc, exprList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
this.expect(types.parenR);

if (canBeArrow &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types.arrow)) {
  this.checkPatternErrors(refDestructuringErrors, false);
  this.checkYieldAwaitInDefaultParams();
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  return this.<span class="apidocCodeKeywordSpan">parseParenArrowList</span>(startPos, startLoc, exprList)
}

if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
if (spreadStart) { this.unexpected(spreadStart); }
this.checkExpressionErrors(refDestructuringErrors, true);
this.yieldPos = oldYieldPos || this.yieldPos;
this.awaitPos = oldAwaitPos || this.awaitPos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseParenExpression" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseParenExpression">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseParenExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(&quot;do&quot;);
  this.labels.pop();
  this.expect(types._while);
  node.test = this.<span class="apidocCodeKeywordSpan">parseParenExpression</span>();
  if (this.options.ecmaVersion &gt;= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, &quot;DoWhileStatement&quot;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseParenItem" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseParenItem">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseParenItem
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(item) {
  return item
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
while (this.type !== types.parenR) {
  first ? first = false : this.expect(types.comma);
  if (allowTrailingComma &amp;&amp; this.afterTrailingComma(types.parenR, true)) {
    lastIsComma = true;
    break
  } else if (this.type === types.ellipsis) {
    spreadStart = this.start;
    exprList.push(this.<span class="apidocCodeKeywordSpan">parseParenItem</span>(this.parseRestBinding()));
    if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
    break
  } else {
    exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
  }
}
var innerEndPos = this.start, innerEndLoc = this.startLoc;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseProperty" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseProperty">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseProperty
        <span class="apidocSignatureSpan">(isPattern, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types.comma) {
        this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;);
      }
      return this.finishNode(prop, &quot;RestElement&quot;)
    }
    // To disallow parenthesized identifier via `this.toAssignable()`.
    if (this.type === types.parenL &amp;&amp; refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign &lt; 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }
      if (refDestructuringErrors.parenthesizedBind &lt; 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types.comma &amp;&amp; refDestructuringErrors &amp;&amp; refDestructuringErrors.trailingComma &lt; 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, &quot;SpreadElement&quot;)
  }
  if (this.options.ecmaVersion &gt;= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern &amp;&amp; !containsEsc &amp;&amp; this.options.ecmaVersion &gt;= 8 &amp;&amp; !isGenerator &amp;&amp; this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, &quot;Property&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this.<span class="apidocCodeKeywordSpan">parseProperty</span>(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? &quot;ObjectPattern&quot; : &quot;ObjectExpression&quot;)
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parsePropertyName" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parsePropertyName">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parsePropertyName
        <span class="apidocSignatureSpan">(prop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prop) {
  if (this.options.ecmaVersion &gt;= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.
allowReserved !== &quot;never&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
  } else if (tryContextual(&quot;get&quot;)) {
    method.kind = &quot;get&quot;;
  } else if (tryContextual(&quot;set&quot;)) {
    method.kind = &quot;set&quot;;
  }
}
if (!method.key) { this.<span class="apidocCodeKeywordSpan">parsePropertyName</span>(method); }
var key = method.key;
var allowsDirectSuper = false;
if (!method.computed &amp;&amp; !method.static &amp;&amp; (key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;constructor
&quot; ||
    key.type === &quot;Literal&quot; &amp;&amp; key.value === &quot;constructor&quot;)) {
  if (method.kind !== &quot;method&quot;) { this.raise(key.start, &quot;Constructor can&apos;t have get/set modifier&quot;); }
  if (isGenerator) { this.raise(key.start, &quot;Constructor can&apos;t be a generator&quot;); }
  if (isAsync) { this.raise(key.start, &quot;Constructor can&apos;t be an async method&quot;); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parsePropertyValue" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parsePropertyValue">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parsePropertyValue
        <span class="apidocSignatureSpan">(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) &amp;&amp; this.type === types.colon)
    { this.unexpected(); }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors
);
    prop.kind = &quot;init&quot;;
  } else if (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.type === types.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = &quot;init&quot;;
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern &amp;&amp; !containsEsc &amp;&amp;
             this.options.ecmaVersion &gt;= 5 &amp;&amp; !prop.computed &amp;&amp; prop.key.type === &quot;Identifier&quot; &amp;&amp;
             (prop.key.name === &quot;get&quot; || prop.key.name === &quot;set&quot;) &amp;&amp;
             (this.type !== types.comma &amp;&amp; this.type !== types.braceR)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === &quot;get&quot; ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === &quot;get&quot;)
        { this.raiseRecoverable(start, &quot;getter should have no params&quot;); }
      else
        { this.raiseRecoverable(start, &quot;setter should have exactly one param&quot;); }
    } else {
      if (prop.kind === &quot;set&quot; &amp;&amp; prop.value.params[0].type === &quot;RestElement&quot;)
        { this.raiseRecoverable(prop.value.params[0].start, &quot;Setter cannot use rest params&quot;); }
    }
  } else if (this.options.ecmaVersion &gt;= 6 &amp;&amp; !prop.computed &amp;&amp; prop.key.type === &quot;Identifier&quot;) {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.checkUnreserved(prop.key);
    if (prop.key.name === &quot;await&quot; &amp;&amp; !this.awaitIdentPos)
      { this.awaitIdentPos = startPos; }
    prop.kind = &quot;init&quot;;
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq &amp;&amp; refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign &lt; 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (!isPattern &amp;&amp; !containsEsc &amp;&amp; this.options.ecmaVersion &gt;= 8 &amp;&amp; !isGenerator &amp;&amp; this.isAsyncProp
(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.<span class="apidocCodeKeywordSpan">parsePropertyValue</span>(prop, isPattern, isGenerator, isAsync, startPos, startLoc,
refDestructuringErrors, containsEsc);
  return this.finishNode(prop, &quot;Property&quot;)
};

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc
) {
  if ((isGenerator || isAsync) &amp;&amp; this.type === types.colon)
    { this.unexpected(); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseRestBinding" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseRestBinding">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseRestBinding
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 &amp;&amp; this.type !== types.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, &quot;RestElement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
if (first) { first = false; }
else { this.expect(types.comma); }
if (allowEmpty &amp;&amp; this.type === types.comma) {
  elts.push(null);
} else if (allowTrailingComma &amp;&amp; this.afterTrailingComma(close)) {
  break
} else if (this.type === types.ellipsis) {
  var rest = this.<span class="apidocCodeKeywordSpan">parseRestBinding</span>();
  this.parseBindingListItem(rest);
  elts.push(rest);
  if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
  this.expect(close);
  break
} else {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseReturnStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseReturnStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseReturnStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  if (!this.inFunction &amp;&amp; !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, &quot;&apos;return&apos; outside of function&quot;); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, &quot;ReturnStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.<span class="apidocCodeKeywordSpan">parseReturnStatement</span>(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseSpread" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseSpread">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseSpread
        <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, &quot;SpreadElement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    if (allowTrailingComma &amp;&amp; this.afterTrailingComma(close)) { break }
  } else { first = false; }

  var elt = (void 0);
  if (allowEmpty &amp;&amp; this.type === types.comma)
    { elt = null; }
  else if (this.type === types.ellipsis) {
    elt = this.<span class="apidocCodeKeywordSpan">parseSpread</span>(refDestructuringErrors);
    if (refDestructuringErrors &amp;&amp; this.type === types.comma &amp;&amp; refDestructuringErrors.trailingComma &lt; 0)
      { refDestructuringErrors.trailingComma = this.start; }
  } else {
    elt = this.parseMaybeAssign(false, refDestructuringErrors);
  }
  elts.push(elt);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseStatement
        <span class="apidocSignatureSpan">(context, topLevel, exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
    starttype = types._var;
    kind = &quot;let&quot;;
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types._debugger: return this.parseDebuggerStatement(node)
  case types._do: return this.parseDoStatement(node)
  case types._for: return this.parseForStatement(node)
  case types._function:
    // Function as sole body of either an if statement or a labeled statement
    // works, but not when it is part of a labeled statement that is the sole
    // body of an if statement.
    if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.options.ecmaVersion &gt;= 6) { this.unexpected
(); }
    return this.parseFunctionStatement(node, false, !context)
  case types._class:
    if (context) { this.unexpected(); }
    return this.parseClass(node, true)
  case types._if: return this.parseIfStatement(node)
  case types._return: return this.parseReturnStatement(node)
  case types._switch: return this.parseSwitchStatement(node)
  case types._throw: return this.parseThrowStatement(node)
  case types._try: return this.parseTryStatement(node)
  case types._const: case types._var:
    kind = kind || this.value;
    if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types._while: return this.parseWhileStatement(node)
  case types._with: return this.parseWithStatement(node)
  case types.braceL: return this.parseBlock(true, node)
  case types.semi: return this.parseEmptyStatement(node)
  case types._export:
  case types._import:
    if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 40) // &apos;(&apos;
        { return this.parseExpressionStatement(node, this.parseExpression()) }
    }

    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may only appear at the top level&quot;); }
      if (!this.inModule)
        { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may appear only with &apos;sourceType: module&apos;&quot;); }
    }
    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it&apos;s an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name &amp;&amp; expr.type === &quot;Identifier&quot; &amp;&amp; this.eat(types.colon))
      { return this.parseLabeledStatement(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function(node) {
  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this.<span class="apidocCodeKeywordSpan">parseStatement</span>(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i &lt; list.length; i += 1)
      {
        var name = list[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseSubscript" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseSubscript">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseSubscript
        <span class="apidocSignatureSpan">(base, startPos, startLoc, noCalls, maybeAsyncArrow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
  var computed = this.eat(types.bracketL);
  if (computed || this.eat(types.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== &quot;never&quot;);
    node.computed = !!computed;
    if (computed) { this.expect(types.bracketR); }
    base = this.finishNode(node, &quot;MemberExpression&quot;);
  } else if (!noCalls &amp;&amp; this.eat(types.parenL)) {
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos
 = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion &gt;= 8 &amp;&amp; base.type !== &quot;Import&quot;, false, refDestructuringErrors
);
    if (maybeAsyncArrow &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos &gt; 0)
        { this.raise(this.awaitIdentPos, &quot;Cannot use &apos;await&apos; as identifier inside an async function&quot;); }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (node$1.callee.type === &quot;Import&quot;) {
      if (node$1.arguments.length !== 1) {
        this.raise(node$1.start, &quot;import() requires exactly one argument&quot;);
      }

      var importArg = node$1.arguments[0];
      if (importArg &amp;&amp; importArg.type === &quot;SpreadElement&quot;) {
        this.raise(importArg.start, &quot;... is not allowed in import()&quot;);
      }
    }
    base = this.finishNode(node$1, &quot;CallExpression&quot;);
  } else if (this.type === types.backQuote) {
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({isTagged: true});
    base = this.finishNode(node$2, &quot;TaggedTemplateExpression&quot;);
  }
  return base
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return result
};

pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
  var maybeAsyncArrow = this.options.ecmaVersion &gt;= 8 &amp;&amp; base.type === &quot;Identifier&quot; &amp;&amp; base.name === &
quot;async&quot; &amp;&amp;
      this.lastTokEnd === base.end &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.input.slice(base.start, base.end) === &
quot;async&quot;;
  while (true) {
    var element = this.<span class="apidocCodeKeywordSpan">parseSubscript</span>(base, startPos, startLoc, noCalls, maybeAsyncArrow
);
    if (element === base || element.type === &quot;ArrowFunctionExpression&quot;) { return element }
    base = element;
  }
};

pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
  var computed = this.eat(types.bracketL);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseSubscripts" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseSubscripts">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseSubscripts
        <span class="apidocSignatureSpan">(base, startPos, startLoc, noCalls)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(base, startPos, startLoc, noCalls) {
  var maybeAsyncArrow = this.options.ecmaVersion &gt;= 8 &amp;&amp; base.type === &quot;Identifier&quot; &amp;&amp; base.name === &quot;async&quot; &amp;&amp;
      this.lastTokEnd === base.end &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.input.slice(base.start, base.end) === &quot;async&quot;;
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
    if (element === base || element.type === &quot;ArrowFunctionExpression&quot;) { return element }
    base = element;
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === &quot;ArrowFunctionExpression&quot; &amp;&amp; this.input.slice(this.lastTokStart, this
.lastTokEnd) !== &quot;)&quot;;
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
  var result = this.<span class="apidocCodeKeywordSpan">parseSubscripts</span>(expr, startPos, startLoc);
  if (refDestructuringErrors &amp;&amp; result.type === &quot;MemberExpression&quot;) {
    if (refDestructuringErrors.parenthesizedAssign &gt;= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind &gt;= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseSwitchStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseSwitchStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseSwitchStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types.braceR;) {
    if (this.type === types._case || this.type === types._default) {
      var isCase = this.type === types._case;
      if (cur) { this.finishNode(cur, &quot;SwitchCase&quot;); }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, &quot;Multiple default clauses&quot;); }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, &quot;SwitchCase&quot;); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, &quot;SwitchStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.<span class="apidocCodeKeywordSpan">parseSwitchStatement</span>(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseTemplate" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseTemplate">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseTemplate
        <span class="apidocSignatureSpan">(ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(ref) {
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types.eof) { this.raise(this.pos, &quot;Unterminated template literal&quot;); }
    this.expect(types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, &quot;TemplateLiteral&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        this.raise(importArg.start, &quot;... is not allowed in import()&quot;);
      }
    }
    base = this.finishNode(node$1, &quot;CallExpression&quot;);
  } else if (this.type === types.backQuote) {
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.<span class="apidocCodeKeywordSpan">parseTemplate</span>({isTagged: true});
    base = this.finishNode(node$2, &quot;TaggedTemplateExpression&quot;);
  }
  return base
};

// Parse an atomic expression  either a single token that is an
// expression, an expression started by a keyword like `function` or
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseTemplateElement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseTemplateElement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseTemplateElement
        <span class="apidocSignatureSpan">(ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, &quot;Bad escape sequence in untagged template literal&quot;);
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, &quot;\n&quot;),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, &quot;TemplateElement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  pp$3.parseTemplate = function(ref) {
if ( ref === void 0 ) ref = {};
var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

var node = this.startNode();
this.next();
node.expressions = [];
var curElt = this.<span class="apidocCodeKeywordSpan">parseTemplateElement</span>({isTagged: isTagged});
node.quasis = [curElt];
while (!curElt.tail) {
  if (this.type === types.eof) { this.raise(this.pos, &quot;Unterminated template literal&quot;); }
  this.expect(types.dollarBraceL);
  node.expressions.push(this.parseExpression());
  this.expect(types.braceR);
  node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseThrowStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseThrowStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseThrowStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, &quot;Illegal newline after throw&quot;); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, &quot;ThrowStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return this.parseFunctionStatement(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.<span class="apidocCodeKeywordSpan">parseThrowStatement</span>(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.parseWithStatement(node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseTopLevel" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseTopLevel">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseTopLevel
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i &lt; list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, (&quot;Export &apos;&quot; + name + &quot;&apos; is not defined&quot;));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, &quot;Program&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },
allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.<span class="apidocCodeKeywordSpan">parseTopLevel</span>(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_SUPER) &gt; 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; 0 };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseTryStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseTryStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseTryStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === &quot;Identifier&quot;;
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types.parenR);
    } else {
      if (this.options.ecmaVersion &lt; 10) { this.unexpected(); }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, &quot;CatchClause&quot;);
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler &amp;&amp; !node.finalizer)
    { this.raise(node.start, &quot;Missing catch or finally clause&quot;); }
  return this.finishNode(node, &quot;TryStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.<span class="apidocCodeKeywordSpan">parseTryStatement</span>(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.parseWithStatement(node)
case types.braceL: return this.parseBlock(true, node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseVar" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseVar">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseVar
        <span class="apidocSignatureSpan">(node, isFor, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === &quot;const&quot; &amp;&amp; !(this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;)))) {
      this.unexpected();
    } else if (decl.id.type !== &quot;Identifier&quot; &amp;&amp; !(isFor &amp;&amp; (this.type === types._in || this.isContextual(&quot;of&quot;)))) {
      this.raise(this.lastTokEnd, &quot;Complex binding patterns require an initialization value&quot;);
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, &quot;VariableDeclarator&quot;));
    if (!this.eat(types.comma)) { break }
  }
  return node
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, null)
}
var isLet = this.isLet();
if (this.type === types._var || this.type === types._const || isLet) {
  var init$1 = this.startNode(), kind = isLet ? &quot;let&quot; : this.value;
  this.next();
  this.<span class="apidocCodeKeywordSpan">parseVar</span>(init$1, true, kind);
  this.finishNode(init$1, &quot;VariableDeclaration&quot;);
  if ((this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) &amp;&amp; init
$1.declarations.length === 1) {
    if (this.options.ecmaVersion &gt;= 9) {
      if (this.type === types._in) {
        if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt &gt; -1; }
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseVarId" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseVarId">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseVarId
        <span class="apidocSignatureSpan">(decl, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, kind === &quot;var&quot; ? BIND_VAR : BIND_LEXICAL, false);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// Parse a list of variable declarations.

pp$1.parseVar = function(node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.<span class="apidocCodeKeywordSpan">parseVarId</span>(decl, kind);
    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === &quot;const&quot; &amp;&amp; !(this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this
.isContextual(&quot;of&quot;)))) {
      this.unexpected();
    } else if (decl.id.type !== &quot;Identifier&quot; &amp;&amp; !(isFor &amp;&amp; (this.type === types._in || this.isContextual
(&quot;of&quot;)))) {
      this.raise(this.lastTokEnd, &quot;Complex binding patterns require an initialization value&quot;);
    } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseVarStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseVarStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseVarStatement
        <span class="apidocSignatureSpan">(node, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, &quot;VariableDeclaration&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.<span class="apidocCodeKeywordSpan">parseVarStatement</span>(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.parseWithStatement(node)
case types.braceL: return this.parseBlock(true, node)
case types.semi: return this.parseEmptyStatement(node)
case types._export:
case types._import:
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseWhileStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseWhileStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseWhileStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(&quot;while&quot;);
  this.labels.pop();
  return this.finishNode(node, &quot;WhileStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.<span class="apidocCodeKeywordSpan">parseWhileStatement</span>(node)
case types._with: return this.parseWithStatement(node)
case types.braceL: return this.parseBlock(true, node)
case types.semi: return this.parseEmptyStatement(node)
case types._export:
case types._import:
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
    skipWhiteSpace.lastIndex = this.pos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseWithStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseWithStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseWithStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  if (this.strict) { this.raise(this.start, &quot;&apos;with&apos; in strict mode&quot;); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(&quot;with&quot;);
  return this.finishNode(node, &quot;WithStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.<span class="apidocCodeKeywordSpan">parseWithStatement</span>(node)
case types.braceL: return this.parseBlock(true, node)
case types.semi: return this.parseEmptyStatement(node)
case types._export:
case types._import:
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseYield" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.parseYield">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>parseYield
        <span class="apidocSignatureSpan">(noIn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(noIn) {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star &amp;&amp; !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign(noIn);
  }
  return this.finishNode(node, &quot;YieldExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  };

  // Parse an assignment expression. This includes applications of
  // operators like `+=`.

  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
if (this.isContextual(&quot;yield&quot;)) {
  if (this.inGenerator) { return this.<span class="apidocCodeKeywordSpan">parseYield</span>(noIn) }
  // The tokenizer will assume an expression is allowed after
  // `yield`, but this isn&apos;t that kind of yield
  else { this.exprAllowed = false; }
}

var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;
if (refDestructuringErrors) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.raise" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.raise">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>raise
        <span class="apidocSignatureSpan">(pos, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += &quot; (&quot; + loc.line + &quot;:&quot; + loc.column + &quot;)&quot;;
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.<span class="apidocCodeKeywordSpan">raise</span>(pos != null ? pos : this.start, &quot;Unexpected token&quot;);
};

function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.raiseRecoverable" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.raiseRecoverable">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>raiseRecoverable
        <span class="apidocSignatureSpan">(pos, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += &quot; (&quot; + loc.line + &quot;:&quot; + loc.column + &quot;)&quot;;
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.doubleProto =
    -1;
}

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma &gt; -1)
    { this.<span class="apidocCodeKeywordSpan">raiseRecoverable</span>(refDestructuringErrors.trailingComma, &quot;Comma is not
permitted after the rest element&quot;); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens &gt; -1) { this.raiseRecoverable(parens, &quot;Parenthesized pattern&quot;); }
};

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readCodePoint" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readCodePoint">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readCodePoint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // &apos;{&apos;
    if (this.options.ecmaVersion &lt; 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf(&quot;}&quot;, this.pos) - this.pos);
    ++this.pos;
    if (code &gt; 0x10FFFF) { this.invalidStringToken(codePos, &quot;Code point out of bounds&quot;); }
  } else {
    code = this.readHexChar(4);
  }
  return code
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  pp$9.readEscapedChar = function(inTemplate) {
var ch = this.input.charCodeAt(++this.pos);
++this.pos;
switch (ch) {
case 110: return &quot;\n&quot; // &apos;n&apos; -&gt; &apos;\n&apos;
case 114: return &quot;\r&quot; // &apos;r&apos; -&gt; &apos;\r&apos;
case 120: return String.fromCharCode(this.readHexChar(2)) // &apos;x&apos;
case 117: return codePointToString$1(this.<span class="apidocCodeKeywordSpan">readCodePoint</span>()) // &apos;u&apos;
case 116: return &quot;\t&quot; // &apos;t&apos; -&gt; &apos;\t&apos;
case 98: return &quot;\b&quot; // &apos;b&apos; -&gt; &apos;\b&apos;
case 118: return &quot;\u000b&quot; // &apos;v&apos; -&gt; &apos;\u000b&apos;
case 102: return &quot;\f&quot; // &apos;f&apos; -&gt; &apos;\f&apos;
case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // &apos;\r\n&apos;
case 10: // &apos; \n&apos;
  if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readEscapedChar" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readEscapedChar">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readEscapedChar
        <span class="apidocSignatureSpan">(inTemplate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return &quot;\n&quot; // &apos;n&apos; -&gt; &apos;\n&apos;
  case 114: return &quot;\r&quot; // &apos;r&apos; -&gt; &apos;\r&apos;
  case 120: return String.fromCharCode(this.readHexChar(2)) // &apos;x&apos;
  case 117: return codePointToString$1(this.readCodePoint()) // &apos;u&apos;
  case 116: return &quot;\t&quot; // &apos;t&apos; -&gt; &apos;\t&apos;
  case 98: return &quot;\b&quot; // &apos;b&apos; -&gt; &apos;\b&apos;
  case 118: return &quot;\u000b&quot; // &apos;v&apos; -&gt; &apos;\u000b&apos;
  case 102: return &quot;\f&quot; // &apos;f&apos; -&gt; &apos;\f&apos;
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // &apos;\r\n&apos;
  case 10: // &apos; \n&apos;
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return &quot;&quot;
  default:
    if (ch &gt;= 48 &amp;&amp; ch &lt;= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal &gt; 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== &quot;0&quot; || ch === 56 || ch === 57) &amp;&amp; (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? &quot;Octal literal in template string&quot;
            : &quot;Octal literal in strict mode&quot;
        );
      }
      return String.fromCharCode(octal)
    }
    if (isNewLine(ch)) {
      // Unicode new line characters after \ get removed from output in both
      // template literals and strings
      return &quot;&quot;
    }
    return String.fromCharCode(ch)
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
var out = &quot;&quot;, chunkStart = ++this.pos;
for (;;) {
  if (this.pos &gt;= this.input.length) { this.raise(this.start, &quot;Unterminated string constant&quot;); }
  var ch = this.input.charCodeAt(this.pos);
  if (ch === quote) { break }
  if (ch === 92) { // &apos;\&apos;
    out += this.input.slice(chunkStart, this.pos);
    out += this.<span class="apidocCodeKeywordSpan">readEscapedChar</span>(false);
    chunkStart = this.pos;
  } else {
    if (isNewLine(ch, this.options.ecmaVersion &gt;= 10)) { this.raise(this.start, &quot;Unterminated string constant&quot;); }
    ++this.pos;
  }
}
out += this.input.slice(chunkStart, this.pos++);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readHexChar" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readHexChar">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readHexChar
        <span class="apidocSignatureSpan">(len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, &quot;Bad character escape sequence&quot;); }
  return n
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

pp$9.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // &apos;{&apos;
    if (this.options.ecmaVersion &lt; 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.<span class="apidocCodeKeywordSpan">readHexChar</span>(this.input.indexOf(&quot;}&quot;, this.pos) - this.pos);
    ++this.pos;
    if (code &gt; 0x10FFFF) { this.invalidStringToken(codePos, &quot;Code point out of bounds&quot;); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readInt" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readInt">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readInt
        <span class="apidocSignatureSpan">(radix, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(radix, len) {
  var start = this.pos, total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i &lt; e; ++i) {
    var code = this.input.charCodeAt(this.pos), val = (void 0);
    if (code &gt;= 97) { val = code - 97 + 10; } // a
    else if (code &gt;= 65) { val = code - 65 + 10; } // A
    else if (code &gt;= 48 &amp;&amp; code &lt;= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val &gt;= radix) { break }
    ++this.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null &amp;&amp; this.pos - start !== len) { return null }

  return total
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

  return total
};

pp$9.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.<span class="apidocCodeKeywordSpan">readInt</span>(radix);
  if (val == null) { this.raise(this.start + 2, &quot;Expected number in radix &quot; + radix); }
  if (this.options.ecmaVersion &gt;= 11 &amp;&amp; this.input.charCodeAt(this.pos) === 110) {
    val = typeof BigInt !== &quot;undefined&quot; ? BigInt(this.input.slice(start, this.pos)) : null;
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, &quot;Identifier directly after number&quot;); }
  return this.finishToken(types.num, val)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readInvalidTemplateToken" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readInvalidTemplateToken">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readInvalidTemplateToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  for (; this.pos &lt; this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
    case &quot;\\&quot;:
      ++this.pos;
      break

    case &quot;$&quot;:
      if (this.input[this.pos + 1] !== &quot;{&quot;) {
        break
      }
    // falls through

    case &quot;`&quot;:
      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

    // no default
    }
  }
  this.raise(this.start, &quot;Unterminated template&quot;);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

pp$9.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.<span class="apidocCodeKeywordSpan">readInvalidTemplateToken</span>();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readNumber" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readNumber">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readNumber
        <span class="apidocSignatureSpan">(startsWithDot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot &amp;&amp; this.readInt(10) === null) { this.raise(start, &quot;Invalid number&quot;); }
  var octal = this.pos - start &gt;= 2 &amp;&amp; this.input.charCodeAt(start) === 48;
  if (octal &amp;&amp; this.strict) { this.raise(start, &quot;Invalid number&quot;); }
  if (octal &amp;&amp; /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  var next = this.input.charCodeAt(this.pos);
  if (!octal &amp;&amp; !startsWithDot &amp;&amp; this.options.ecmaVersion &gt;= 11 &amp;&amp; next === 110) {
    var str$1 = this.input.slice(start, this.pos);
    var val$1 = typeof BigInt !== &quot;undefined&quot; ? BigInt(str$1) : null;
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, &quot;Identifier directly after number&quot;); }
    return this.finishToken(types.num, val$1)
  }
  if (next === 46 &amp;&amp; !octal) { // &apos;.&apos;
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) &amp;&amp; !octal) { // &apos;eE&apos;
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // &apos;+-&apos;
    if (this.readInt(10) === null) { this.raise(start, &quot;Invalid number&quot;); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, &quot;Identifier directly after number&quot;); }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$9.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next &gt;= 48 &amp;&amp; next &lt;= 57) { return this.<span class="apidocCodeKeywordSpan">readNumber</span>(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; next === 46 &amp;&amp; next2 === 46) { // 46 = dot &apos;.&apos;
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readRadixNumber" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readRadixNumber">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readRadixNumber
        <span class="apidocSignatureSpan">(radix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, &quot;Expected number in radix &quot; + radix); }
  if (this.options.ecmaVersion &gt;= 11 &amp;&amp; this.input.charCodeAt(this.pos) === 110) {
    val = typeof BigInt !== &quot;undefined&quot; ? BigInt(this.input.slice(start, this.pos)) : null;
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, &quot;Identifier directly after number&quot;); }
  return this.finishToken(types.num, val)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case 96: // &apos;`&apos;
  if (this.options.ecmaVersion &lt; 6) { break }
  ++this.pos;
  return this.finishToken(types.backQuote)

case 48: // &apos;0&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 120 || next === 88) { return this.<span class="apidocCodeKeywordSpan">readRadixNumber</span>(16) } // &apos;0x&apos
;, &apos;0X&apos; - hex number
  if (this.options.ecmaVersion &gt;= 6) {
    if (next === 111 || next === 79) { return this.readRadixNumber(8) } // &apos;0o&apos;, &apos;0O&apos; - octal number
    if (next === 98 || next === 66) { return this.readRadixNumber(2) } // &apos;0b&apos;, &apos;0B&apos; - binary number
  }

// Anything else beginning with a digit is an integer, octal
// number, or float.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readRegexp" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readRegexp">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readRegexp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this.pos &gt;= this.input.length) { this.raise(start, &quot;Unterminated regular expression&quot;); }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) { this.raise(start, &quot;Unterminated regular expression&quot;); }
    if (!escaped) {
      if (ch === &quot;[&quot;) { inClass = true; }
      else if (ch === &quot;]&quot; &amp;&amp; inClass) { inClass = false; }
      else if (ch === &quot;/&quot; &amp;&amp; !inClass) { break }
      escaped = ch === &quot;\\&quot;;
    } else { escaped = false; }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  // expression, an expression started by a keyword like `function` or
  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
  // or `{}`.

  pp$3.parseExprAtom = function(refDestructuringErrors) {
// If a division operator appears in an expression position, the
// tokenizer got confused, and we force it to read a regexp instead.
if (this.type === types.slash) { this.<span class="apidocCodeKeywordSpan">readRegexp</span>(); }

var node, canBeArrow = this.potentialArrowAt === this.start;
switch (this.type) {
case types._super:
  if (!this.allowSuper)
    { this.raise(this.start, &quot;&apos;super&apos; keyword outside a method&quot;); }
  node = this.startNode();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readString" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readString">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readString
        <span class="apidocSignatureSpan">(quote)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(quote) {
  var out = &quot;&quot;, chunkStart = ++this.pos;
  for (;;) {
    if (this.pos &gt;= this.input.length) { this.raise(this.start, &quot;Unterminated string constant&quot;); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) { break }
    if (ch === 92) { // &apos;\&apos;
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (isNewLine(ch, this.options.ecmaVersion &gt;= 10)) { this.raise(this.start, &quot;Unterminated string constant&quot;); }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// Anything else beginning with a digit is an integer, octal
// number, or float.
case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
  return this.readNumber(false)

// Quotes produce strings.
case 34: case 39: // &apos;&quot;&apos;, &quot;&apos;&quot;
  return this.<span class="apidocCodeKeywordSpan">readString</span>(code)

// Operators are parsed inline in tiny state machines. &apos;=&apos; (61) is
// often referred to. `finishOp` simply skips the amount of
// characters it is given as second argument, and returns a token
// of the type given by its first argument.

case 47: // &apos;/&apos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readTmplToken" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readTmplToken">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readTmplToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var out = &quot;&quot;, chunkStart = this.pos;
  for (;;) {
    if (this.pos &gt;= this.input.length) { this.raise(this.start, &quot;Unterminated template&quot;); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 &amp;&amp; this.input.charCodeAt(this.pos + 1) === 123) { // &apos;`&apos;, &apos;${&apos;
      if (this.pos === this.start &amp;&amp; (this.type === types.template || this.type === types.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types.dollarBraceL)
        } else {
          ++this.pos;
          return this.finishToken(types.backQuote)
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types.template, out)
    }
    if (ch === 92) { // &apos;\&apos;
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
      case 10:
        out += &quot;\n&quot;;
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$9.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.<span class="apidocCodeKeywordSpan">readTmplToken</span>();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
  // identifiers, so &apos;\&apos; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &apos;\&apos; */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos &gt;= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.<span class="apidocCodeKeywordSpan">readToken</span>(this.fullCharCodeAtPos()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
  // identifiers, so &apos;\&apos; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &apos;\&apos; */)
    { return this.readWord() }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_caret" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_caret">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken_caret
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() { // &apos;^&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.bitwiseXOR, 1)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case 37: case 42: // &apos;%*&apos;
  return this.readToken_mult_modulo_exp(code)

case 124: case 38: // &apos;|&amp;&apos;
  return this.readToken_pipe_amp(code)

case 94: // &apos;^&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_caret</span>()

case 43: case 45: // &apos;+-&apos;
  return this.readToken_plus_min(code)

case 60: case 62: // &apos;&lt;&gt;&apos;
  return this.readToken_lt_gt(code)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_dot" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_dot">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken_dot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next &gt;= 48 &amp;&amp; next &lt;= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; next === 46 &amp;&amp; next2 === 46) { // 46 = dot &apos;.&apos;
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  };

  pp$9.getTokenFromCode = function(code) {
switch (code) {
// The interpretation of a dot depends on whether it is followed
// by a digit or another two dots.
case 46: // &apos;.&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_dot</span>()

// Punctuation tokens.
case 40: ++this.pos; return this.finishToken(types.parenL)
case 41: ++this.pos; return this.finishToken(types.parenR)
case 59: ++this.pos; return this.finishToken(types.semi)
case 44: ++this.pos; return this.finishToken(types.comma)
case 91: ++this.pos; return this.finishToken(types.bracketL)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_eq_excl" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_eq_excl">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken_eq_excl
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) { // &apos;=!&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 &amp;&amp; next === 62 &amp;&amp; this.options.ecmaVersion &gt;= 6) { // &apos;=&gt;&apos;
    this.pos += 2;
    return this.finishToken(types.arrow)
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  case 43: case 45: // &apos;+-&apos;
    return this.readToken_plus_min(code)

  case 60: case 62: // &apos;&lt;&gt;&apos;
    return this.readToken_lt_gt(code)

  case 61: case 33: // &apos;=!&apos;
    return this.<span class="apidocCodeKeywordSpan">readToken_eq_excl</span>(code)

  case 126: // &apos;~&apos;
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, &quot;Unexpected character &apos;&quot; + codePointToString$1(code) + &quot;&apos;&quot;);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_lt_gt" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_lt_gt">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken_lt_gt
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) { // &apos;&lt;&gt;&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 &amp;&amp; this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(types.bitShift, size)
  }
  if (next === 33 &amp;&amp; code === 60 &amp;&amp; !this.inModule &amp;&amp; this.input.charCodeAt(this.pos + 2) === 45 &amp;&amp;
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `&lt;!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types.relational, size)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case 94: // &apos;^&apos;
  return this.readToken_caret()

case 43: case 45: // &apos;+-&apos;
  return this.readToken_plus_min(code)

case 60: case 62: // &apos;&lt;&gt;&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_lt_gt</span>(code)

case 61: case 33: // &apos;=!&apos;
  return this.readToken_eq_excl(code)

case 126: // &apos;~&apos;
  return this.finishOp(types.prefix, 1)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_mult_modulo_exp" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_mult_modulo_exp">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken_mult_modulo_exp
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) { // &apos;%*&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion &gt;= 7 &amp;&amp; code === 42 &amp;&amp; next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types.assign, size + 1) }
  return this.finishOp(tokentype, size)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// characters it is given as second argument, and returns a token
// of the type given by its first argument.

case 47: // &apos;/&apos;
  return this.readToken_slash()

case 37: case 42: // &apos;%*&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_mult_modulo_exp</span>(code)

case 124: case 38: // &apos;|&amp;&apos;
  return this.readToken_pipe_amp(code)

case 94: // &apos;^&apos;
  return this.readToken_caret()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_pipe_amp" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_pipe_amp">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken_pipe_amp
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) { // &apos;|&amp;&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case 47: // &apos;/&apos;
  return this.readToken_slash()

case 37: case 42: // &apos;%*&apos;
  return this.readToken_mult_modulo_exp(code)

case 124: case 38: // &apos;|&amp;&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_pipe_amp</span>(code)

case 94: // &apos;^&apos;
  return this.readToken_caret()

case 43: case 45: // &apos;+-&apos;
  return this.readToken_plus_min(code)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_plus_min" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_plus_min">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken_plus_min
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) { // &apos;+-&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 &amp;&amp; !this.inModule &amp;&amp; this.input.charCodeAt(this.pos + 2) === 62 &amp;&amp;
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `--&gt;` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.plusMin, 1)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case 124: case 38: // &apos;|&amp;&apos;
  return this.readToken_pipe_amp(code)

case 94: // &apos;^&apos;
  return this.readToken_caret()

case 43: case 45: // &apos;+-&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_plus_min</span>(code)

case 60: case 62: // &apos;&lt;&gt;&apos;
  return this.readToken_lt_gt(code)

case 61: case 33: // &apos;=!&apos;
  return this.readToken_eq_excl(code)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_slash" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readToken_slash">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readToken_slash
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() { // &apos;/&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.slash, 1)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// Operators are parsed inline in tiny state machines. &apos;=&apos; (61) is
// often referred to. `finishOp` simply skips the amount of
// characters it is given as second argument, and returns a token
// of the type given by its first argument.

case 47: // &apos;/&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_slash</span>()

case 37: case 42: // &apos;%*&apos;
  return this.readToken_mult_modulo_exp(code)

case 124: case 38: // &apos;|&amp;&apos;
  return this.readToken_pipe_amp(code)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readWord" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readWord">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readWord
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
    if (this.containsEsc) { this.raiseRecoverable(this.start, &quot;Escape sequence in keyword &quot; + word); }
    type = keywords$1[word];
  }
  return this.finishToken(type, word)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
  // identifiers, so &apos;\&apos; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &apos;\&apos; */)
    { return this.<span class="apidocCodeKeywordSpan">readWord</span>() }

  return this.getTokenFromCode(code)
};

pp$9.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code &lt;= 0xd7ff || code &gt;= 0xe000) { return code }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.readWord1" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.readWord1">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>readWord1
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  this.containsEsc = false;
  var word = &quot;&quot;, first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion &gt;= 6;
  while (this.pos &lt; this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch &lt;= 0xffff ? 1 : 2;
    } else if (ch === 92) { // &quot;\&quot;
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) // &quot;u&quot;
        { this.invalidStringToken(this.pos, &quot;Expecting Unicode escape sequence \\uXXXX&quot;); }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this.invalidStringToken(escStart, &quot;Invalid Unicode escape&quot;); }
      word += codePointToString$1(esc);
      chunkStart = this.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    escaped = ch === &quot;\\&quot;;
  } else { escaped = false; }
  ++this.pos;
}
var pattern = this.input.slice(start, this.pos);
++this.pos;
var flagsStart = this.pos;
var flags = this.<span class="apidocCodeKeywordSpan">readWord1</span>();
if (this.containsEsc) { this.unexpected(flagsStart); }

// Validate pattern
var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
state.reset(start, pattern, flags);
this.validateRegExpFlags(state);
this.validateRegExpPattern(state);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_alternative" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_alternative">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_alternative
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  while (state.pos &lt; state.source.length &amp;&amp; this.regexp_eatTerm(state))
    { }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    state.raise(&quot;Invalid named capture referenced&quot;);
  }
}
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
  pp$8.regexp_disjunction = function(state) {
this.<span class="apidocCodeKeywordSpan">regexp_alternative</span>(state);
while (state.eat(0x7C /* | */)) {
  this.regexp_alternative(state);
}

// Make the same message as V8.
if (this.regexp_eatQuantifier(state, true)) {
  state.raise(&quot;Nothing to repeat&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_classRanges" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_classRanges">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_classRanges
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) &amp;&amp; this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU &amp;&amp; (left === -1 || right === -1)) {
        state.raise(&quot;Invalid character class&quot;);
      }
      if (left !== -1 &amp;&amp; right !== -1 &amp;&amp; left &gt; right) {
        state.raise(&quot;Range out of order in character class&quot;);
      }
    }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$8.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.<span class="apidocCodeKeywordSpan">regexp_classRanges</span>(state);
    if (state.eat(0x5D /* [ */)) {
      return true
    }
    // Unreachable since it threw &quot;unterminated regular expression&quot; error before.
    state.raise(&quot;Unterminated character class&quot;);
  }
  return false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_disjunction" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_disjunction">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_disjunction
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise(&quot;Nothing to repeat&quot;);
  }
  if (state.eat(0x7B /* { */)) {
    state.raise(&quot;Lone quantifier brackets&quot;);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
state.lastStringValue = &quot;&quot;;
state.lastAssertionIsQuantifiable = false;
state.numCapturingParens = 0;
state.maxBackReference = 0;
state.groupNames.length = 0;
state.backReferenceNames.length = 0;

this.<span class="apidocCodeKeywordSpan">regexp_disjunction</span>(state);

if (state.pos !== state.source.length) {
  // Make the same messages as V8.
  if (state.eat(0x29 /* ) */)) {
    state.raise(&quot;Unmatched &apos;)&apos;&quot;);
  }
  if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatAssertion" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatAssertion">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatAssertion
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) &amp;&amp; state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion &gt;= 9) {
      lookbehind = state.eat(0x3C /* &lt; */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise(&quot;Unterminated group&quot;);
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp$8.regexp_alternative = function(state) {
  while (state.pos &lt; state.source.length &amp;&amp; this.regexp_eatTerm(state))
    { }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$8.regexp_eatTerm = function(state) {
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatAssertion</span>(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable &amp;&amp; this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise(&quot;Invalid quantifier&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatAtom" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatAtom">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatAtom
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      if (state.switchU) {
        state.raise(&quot;Invalid quantifier&quot;);
      }
    }
    return true
  }

  if (state.switchU ? this.<span class="apidocCodeKeywordSpan">regexp_eatAtom</span>(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatAtomEscape" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatAtomEscape">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatAtomEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN &amp;&amp; this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise(&quot;Invalid unicode escape&quot;);
    }
    state.raise(&quot;Invalid escape&quot;);
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatAtomEscape</span>(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatUncapturingGroup = function(state) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatBackReference" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatBackReference">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatBackReference
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n &gt; state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n &lt;= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* &lt;ZWNJ&gt; */ || ch ===
0x200D /* &lt;ZWJ&gt; */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.<span class="apidocCodeKeywordSpan">regexp_eatBackReference</span>(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN &amp;&amp; this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatBracedQuantifier" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatBracedQuantifier">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatBracedQuantifier
        <span class="apidocSignatureSpan">(state, noError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) &amp;&amp; this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 &amp;&amp; max &lt; min &amp;&amp; !noError) {
          state.raise(&quot;numbers out of order in {} quantifier&quot;);
        }
        return true
      }
    }
    if (state.switchU &amp;&amp; !noError) {
      state.raise(&quot;Incomplete quantifier&quot;);
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatBracedQuantifier</span>(state, noError)
  )
};
pp$8.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatCControlLetter" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatCControlLetter">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatCControlLetter
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatCControlLetter</span>(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatCapturingGroup" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatCapturingGroup">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatCapturingGroup
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion &gt;= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise(&quot;Invalid group&quot;);
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise(&quot;Unterminated group&quot;);
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatCapturingGroup</span>(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatCharacterClass" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatCharacterClass">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatCharacterClass
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.regexp_classRanges(state);
    if (state.eat(0x5D /* [ */)) {
      return true
    }
    // Unreachable since it threw &quot;unterminated regular expression&quot; error before.
    state.raise(&quot;Unterminated character class&quot;);
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatCharacterClass</span>(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatCharacterClassEscape" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatCharacterClassEscape">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatCharacterClassEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true
  }

  if (
    state.switchU &amp;&amp;
    this.options.ecmaVersion &gt;= 9 &amp;&amp;
    (ch === 0x50 /* P */ || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    if (
      state.eat(0x7B /* { */) &amp;&amp;
      this.regexp_eatUnicodePropertyValueExpression(state) &amp;&amp;
      state.eat(0x7D /* } */)
    ) {
      return true
    }
    state.raise(&quot;Invalid property name&quot;);
  }

  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* &lt;ZWNJ&gt; */ || ch ===
0x200D /* &lt;ZWJ&gt; */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatCharacterClassEscape</span>(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN &amp;&amp; this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatCharacterEscape" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatCharacterEscape">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatCharacterEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatCharacterEscape</span>(state) ||
    (state.switchN &amp;&amp; this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatClassAtom" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatClassAtom">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatClassAtom
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise(&quot;Invalid class escape&quot;);
      }
      state.raise(&quot;Invalid escape&quot;);
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* [ */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$8.regexp_classRanges = function(state) {
  while (this.<span class="apidocCodeKeywordSpan">regexp_eatClassAtom</span>(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) &amp;&amp; this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU &amp;&amp; (left === -1 || right === -1)) {
        state.raise(&quot;Invalid character class&quot;);
      }
      if (left !== -1 &amp;&amp; right !== -1 &amp;&amp; left &gt; right) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatClassControlLetter" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatClassControlLetter">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatClassControlLetter
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

if (state.switchU &amp;&amp; state.eat(0x2D /* - */)) {
  state.lastIntValue = 0x2D; /* - */
  return true
}

if (!state.switchU &amp;&amp; state.eat(0x63 /* c */)) {
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatClassControlLetter</span>(state)) {
    return true
  }
  state.pos = start;
}

return (
  this.regexp_eatCharacterClassEscape(state) ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatClassEscape" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatClassEscape">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatClassEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;

  if (state.eat(0x62<span class="apidocCodeCommentSpan"> /* b */)) {
    state.lastIntValue = 0x08; /* &lt;BS&gt; */
</span>    return true
  }

  if (state.switchU &amp;&amp; state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU &amp;&amp; state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
  pp$8.regexp_eatClassAtom = function(state) {
var start = state.pos;

if (state.eat(0x5C /* \ */)) {
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatClassEscape</span>(state)) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    var ch$1 = state.current();
    if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
      state.raise(&quot;Invalid class escape&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatControlEscape" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatControlEscape">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatControlEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (ch === 0x74<span class="apidocCodeCommentSpan"> /* t */) {
    state.lastIntValue = 0x09; /* \t */
</span>    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.<span class="apidocCodeKeywordSpan">regexp_eatControlEscape</span>(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatControlLetter" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatControlLetter">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatControlLetter
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatControlLetter</span>(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatZero = function(state) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatDecimalDigits" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatDecimalDigits">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatDecimalDigits
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$8.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatDecimalDigits</span>(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) &amp;&amp; this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 &amp;&amp; max &lt; min &amp;&amp; !noError) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatDecimalEscape" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatDecimalEscape">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatDecimalEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch &gt;= 0x31 /* 1 */ &amp;&amp; ch &lt;= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) &gt;= 0x30 /* 0 */ &amp;&amp; ch &lt;= 0x39 /* 9 */)
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    }
    state.raise(&quot;Invalid escape&quot;);
  }
  return false
};
pp$8.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatDecimalEscape</span>(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n &gt; state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatExtendedAtom" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatExtendedAtom">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatExtendedAtom
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      if (state.switchU) {
        state.raise(&quot;Invalid quantifier&quot;);
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.<span class="apidocCodeKeywordSpan">regexp_eatExtendedAtom</span>(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatExtendedPatternCharacter" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatExtendedPatternCharacter">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatExtendedPatternCharacter
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (
    ch !== -1 &amp;&amp;
    ch !== 0x24<span class="apidocCodeCommentSpan"> /* $ */ &amp;&amp;
    !(ch &gt;= 0x28 /* ( */ &amp;&amp; ch &lt;= 0x2B /* + */) &amp;&amp;
    ch !== 0x2E /* . */ &amp;&amp;
    ch !== 0x3F /* ? */ &amp;&amp;
    ch !== 0x5B /* [ */ &amp;&amp;
    ch !== 0x5E /* ^ */ &amp;&amp;
    ch !== 0x7C /* | */
</span>  ) {
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatExtendedPatternCharacter</span>(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise(&quot;Nothing to repeat&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatFixedHexDigits" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatFixedHexDigits">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatFixedHexDigits
        <span class="apidocSignatureSpan">(state, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i &lt; length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
var start = state.pos;

if (state.eat(0x75 /* u */)) {
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatFixedHexDigits</span>(state, 4)) {
    var lead = state.lastIntValue;
    if (state.switchU &amp;&amp; lead &gt;= 0xD800 &amp;&amp; lead &lt;= 0xDBFF) {
      var leadSurrogateEnd = state.pos;
      if (state.eat(0x5C /* \ */) &amp;&amp; state.eat(0x75 /* u */) &amp;&amp; this.regexp_eatFixedHexDigits(state, 4)) {
        var trail = state.lastIntValue;
        if (trail &gt;= 0xDC00 &amp;&amp; trail &lt;= 0xDFFF) {
          state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatGroupName" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatGroupName">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatGroupName
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  state.lastStringValue = &quot;&quot;;
  if (state.eat(0x3C /* &lt; */)) {
    if (this.regexp_eatRegExpIdentifierName(state) &amp;&amp; state.eat(0x3E /* &gt; */)) {
      return true
    }
    state.raise(&quot;Invalid capture group name&quot;);
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

// GroupSpecifier[U] ::
//   [empty]
//   `?` GroupName[?U]
pp$8.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatGroupName</span>(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise(&quot;Duplicate capture group name&quot;);
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise(&quot;Invalid group&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatHexDigits" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatHexDigits">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatHexDigits
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    state.lastIntValue = lead;
  }
  return true
}
if (
  state.switchU &amp;&amp;
  state.eat(0x7B /* { */) &amp;&amp;
  this.<span class="apidocCodeKeywordSpan">regexp_eatHexDigits</span>(state) &amp;&amp;
  state.eat(0x7D /* } */) &amp;&amp;
  isValidUnicode(state.lastIntValue)
) {
  return true
}
if (state.switchU) {
  state.raise(&quot;Invalid unicode escape&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatHexEscapeSequence" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatHexEscapeSequence">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatHexEscapeSequence
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise(&quot;Invalid escape&quot;);
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatHexEscapeSequence</span>(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatIdentityEscape" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatIdentityEscape">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatIdentityEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F<span class="apidocCodeCommentSpan"> /* / */)) {
      state.lastIntValue = 0x2F; /* / */
</span>      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ &amp;&amp; (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatIdentityEscape</span>(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatInvalidBracedQuantifier" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatInvalidBracedQuantifier">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatInvalidBracedQuantifier
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise(&quot;Nothing to repeat&quot;);
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp$8.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatInvalidBracedQuantifier</span>(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatKGroupName" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatKGroupName">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatKGroupName
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise(&quot;Invalid named reference&quot;);
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN &amp;&amp; this.<span class="apidocCodeKeywordSpan">regexp_eatKGroupName</span>(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise(&quot;Invalid unicode escape&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatLegacyOctalEscapeSequence" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatLegacyOctalEscapeSequence">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatLegacyOctalEscapeSequence
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 &lt;= 3 &amp;&amp; this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.<span class="apidocCodeKeywordSpan">regexp_eatLegacyOctalEscapeSequence</span>(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatLoneUnicodePropertyNameOrValue" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatLoneUnicodePropertyNameOrValue">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatLoneUnicodePropertyNameOrValue
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatLoneUnicodePropertyNameOrValue</span>(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
};
pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatOctalDigit" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatOctalDigit">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatOctalDigit
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30;<span class="apidocCodeCommentSpan"> /* 0 */
</span>    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatOctalDigit</span>(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 &lt;= 3 &amp;&amp; this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatPatternCharacters" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatPatternCharacters">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatPatternCharacters
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 &amp;&amp; !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.<span class="apidocCodeKeywordSpan">regexp_eatPatternCharacters</span>(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatQuantifier" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatQuantifier">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatQuantifier
        <span class="apidocSignatureSpan">(state, noError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp$8.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatQuantifier</span>(state, true)) {
    state.raise(&quot;Nothing to repeat&quot;);
  }
  if (state.eat(0x7B /* { */)) {
    state.raise(&quot;Lone quantifier brackets&quot;);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatQuantifierPrefix" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatQuantifierPrefix">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatQuantifierPrefix
        <span class="apidocSignatureSpan">(state, noError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$8.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.<span class="apidocCodeKeywordSpan">regexp_eatQuantifierPrefix</span>(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatRegExpIdentifierName" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatRegExpIdentifierName">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierName
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  state.lastStringValue = &quot;&quot;;
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// GroupName[U] ::
//   `&lt;` RegExpIdentifierName[?U] `&gt;`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatGroupName = function(state) {
  state.lastStringValue = &quot;&quot;;
  if (state.eat(0x3C /* &lt; */)) {
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatRegExpIdentifierName</span>(state) &amp;&amp; state.eat(0x3E /* &gt; */)) {
      return true
    }
    state.raise(&quot;Invalid capture group name&quot;);
  }
  return false
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatRegExpIdentifierPart" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatRegExpIdentifierPart">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierPart
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ &amp;&amp; this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = &quot;&quot;;
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.<span class="apidocCodeKeywordSpan">regexp_eatRegExpIdentifierPart</span>(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatRegExpIdentifierStart" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatRegExpIdentifierStart">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierStart
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ &amp;&amp; this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// RegExpIdentifierName[U] ::
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = &quot;&quot;;
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatRegExpIdentifierStart</span>(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatRegExpUnicodeEscapeSequence" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatRegExpUnicodeEscapeSequence">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatRegExpUnicodeEscapeSequence
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (state.switchU &amp;&amp; lead &gt;= 0xD800 &amp;&amp; lead &lt;= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) &amp;&amp; state.eat(0x75 /* u */) &amp;&amp; this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail &gt;= 0xDC00 &amp;&amp; trail &lt;= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      state.switchU &amp;&amp;
      state.eat(0x7B /* { */) &amp;&amp;
      this.regexp_eatHexDigits(state) &amp;&amp;
      state.eat(0x7D /* } */) &amp;&amp;
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (state.switchU) {
      state.raise(&quot;Invalid unicode escape&quot;);
    }
    state.pos = start;
  }

  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  //   `_`
  //   `\` RegExpUnicodeEscapeSequence[?U]
  pp$8.regexp_eatRegExpIdentifierStart = function(state) {
var start = state.pos;
var ch = state.current();
state.advance();

if (ch === 0x5C /* \ */ &amp;&amp; this.<span class="apidocCodeKeywordSpan">regexp_eatRegExpUnicodeEscapeSequence</span>(state)) {
  ch = state.lastIntValue;
}
if (isRegExpIdentifierStart(ch)) {
  state.lastIntValue = ch;
  return true
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatReverseSolidusAtomEscape" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatReverseSolidusAtomEscape">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatReverseSolidusAtomEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatReverseSolidusAtomEscape</span>(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatSyntaxCharacter" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatSyntaxCharacter">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatSyntaxCharacter
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
function isValidUnicode(ch) {
  return ch &gt;= 0 &amp;&amp; ch &lt;= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$8.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatSyntaxCharacter</span>(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatTerm" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatTerm">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatTerm
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable &amp;&amp; this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise(&quot;Invalid quantifier&quot;);
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (state.eat(0x7B /* { */)) {
    state.raise(&quot;Lone quantifier brackets&quot;);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$8.regexp_alternative = function(state) {
  while (state.pos &lt; state.source.length &amp;&amp; this.<span class="apidocCodeKeywordSpan">regexp_eatTerm</span>(state))
    { }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$8.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatUncapturingGroup" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatUncapturingGroup">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatUncapturingGroup
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */) &amp;&amp; state.eat(0x3A /* : */)) {
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        return true
      }
      state.raise(&quot;Unterminated group&quot;);
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatUncapturingGroup</span>(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatUnicodePropertyName" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatUnicodePropertyName">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyName
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = 0;
  state.lastStringValue = &quot;&quot;;
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== &quot;&quot;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  // UnicodePropertyValueExpression ::
  //   UnicodePropertyName `=` UnicodePropertyValue
  //   LoneUnicodePropertyNameOrValue
  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
var start = state.pos;

// UnicodePropertyName `=` UnicodePropertyValue
if (this.<span class="apidocCodeKeywordSpan">regexp_eatUnicodePropertyName</span>(state) &amp;&amp; state.eat(0x3D /* = */)) {
  var name = state.lastStringValue;
  if (this.regexp_eatUnicodePropertyValue(state)) {
    var value = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
    return true
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatUnicodePropertyValue" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatUnicodePropertyValue">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyValue
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = 0;
  state.lastStringValue = &quot;&quot;;
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== &quot;&quot;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  //   LoneUnicodePropertyNameOrValue
  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
var start = state.pos;

// UnicodePropertyName `=` UnicodePropertyValue
if (this.regexp_eatUnicodePropertyName(state) &amp;&amp; state.eat(0x3D /* = */)) {
  var name = state.lastStringValue;
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatUnicodePropertyValue</span>(state)) {
    var value = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
    return true
  }
}
state.pos = start;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatUnicodePropertyValueExpression" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatUnicodePropertyValueExpression">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyValueExpression
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) &amp;&amp; state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.options.ecmaVersion &gt;= 9 &amp;&amp;
  (ch === 0x50 /* P */ || ch === 0x70 /* p */)
) {
  state.lastIntValue = -1;
  state.advance();
  if (
    state.eat(0x7B /* { */) &amp;&amp;
    this.<span class="apidocCodeKeywordSpan">regexp_eatUnicodePropertyValueExpression</span>(state) &amp;&amp;
    state.eat(0x7D /* } */)
  ) {
    return true
  }
  state.raise(&quot;Invalid property name&quot;);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatZero" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_eatZero">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_eatZero
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.current() === 0x30 /* 0 */ &amp;&amp; !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatZero</span>(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_groupSpecifier" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_groupSpecifier">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_groupSpecifier
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise(&quot;Duplicate capture group name&quot;);
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise(&quot;Invalid group&quot;);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion &gt;= 9) {
      this.<span class="apidocCodeKeywordSpan">regexp_groupSpecifier</span>(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise(&quot;Invalid group&quot;);
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_pattern" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_pattern">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_pattern
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = &quot;&quot;;
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise(&quot;Unmatched &apos;)&apos;&quot;);
    }
    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
      state.raise(&quot;Lone quantifier brackets&quot;);
    }
  }
  if (state.maxBackReference &gt; state.numCapturingParens) {
    state.raise(&quot;Invalid escape&quot;);
  }
  for (var i = 0, list = state.backReferenceNames; i &lt; list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise(&quot;Invalid named capture referenced&quot;);
    }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  /**
   * Validate the pattern part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */
  pp$8.validateRegExpPattern = function(state) {
this.<span class="apidocCodeKeywordSpan">regexp_pattern</span>(state);

// The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
// parsing contains a |GroupName|, reparse with the goal symbol
// |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
// exception if _P_ did not conform to the grammar, if any elements of _P_
// were not matched by the parse, or if any Early Error conditions exist.
if (!state.switchN &amp;&amp; this.options.ecmaVersion &gt;= 9 &amp;&amp; state.groupNames.length &gt; 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_validateUnicodePropertyNameAndValue" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_validateUnicodePropertyNameAndValue">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_validateUnicodePropertyNameAndValue
        <span class="apidocSignatureSpan">(state, name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, name, value) {
  if (!has(state.unicodeProperties.nonBinary, name))
    { state.raise(&quot;Invalid property name&quot;); }
  if (!state.unicodeProperties.nonBinary[name].test(value))
    { state.raise(&quot;Invalid property value&quot;); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
var start = state.pos;

// UnicodePropertyName `=` UnicodePropertyValue
if (this.regexp_eatUnicodePropertyName(state) &amp;&amp; state.eat(0x3D /* = */)) {
  var name = state.lastStringValue;
  if (this.regexp_eatUnicodePropertyValue(state)) {
    var value = state.lastStringValue;
    this.<span class="apidocCodeKeywordSpan">regexp_validateUnicodePropertyNameAndValue</span>(state, name, value);
    return true
  }
}
state.pos = start;

// LoneUnicodePropertyNameOrValue
if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_validateUnicodePropertyNameOrValue" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.regexp_validateUnicodePropertyNameOrValue">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>regexp_validateUnicodePropertyNameOrValue
        <span class="apidocSignatureSpan">(state, nameOrValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue))
    { state.raise(&quot;Invalid property name&quot;); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.<span class="apidocCodeKeywordSpan">regexp_validateUnicodePropertyNameOrValue</span>(state, nameOrValue);
    return true
  }
  return false
};
pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!has(state.unicodeProperties.nonBinary, name))
    { state.raise(&quot;Invalid property name&quot;); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.semicolon" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.semicolon">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>semicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (!this.eat(types.semi) &amp;&amp; !this.insertSemicolon()) { this.unexpected(); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  pp$1.parseBreakContinueStatement = function(node, keyword) {
var isBreak = keyword === &quot;break&quot;;
this.next();
if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
else if (this.type !== types.name) { this.unexpected(); }
else {
  node.label = this.parseIdent();
  this.<span class="apidocCodeKeywordSpan">semicolon</span>();
}

// Verify that there is an actual destination to break or
// continue to.
var i = 0;
for (; i &lt; this.labels.length; ++i) {
  var lab = this.labels[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.shouldParseExportStatement" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.shouldParseExportStatement">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>shouldParseExportStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return this.type.keyword === &quot;var&quot; ||
    this.type.keyword === &quot;const&quot; ||
    this.type.keyword === &quot;class&quot; ||
    this.type.keyword === &quot;function&quot; ||
    this.isLet() ||
    this.isAsyncFunction()
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  } else {
    node.declaration = this.parseMaybeAssign();
    this.semicolon();
  }
  return this.finishNode(node, &quot;ExportDefaultDeclaration&quot;)
}
// export var|const|let|function|class ...
if (this.<span class="apidocCodeKeywordSpan">shouldParseExportStatement</span>()) {
  node.declaration = this.parseStatement(null);
  if (node.declaration.type === &quot;VariableDeclaration&quot;)
    { this.checkVariableExport(exports, node.declaration.declarations); }
  else
    { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
  node.specifiers = [];
  node.source = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.skipBlockComment" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.skipBlockComment">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>skipBlockComment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var startLoc = this.options.onComment &amp;&amp; this.curPosition();
  var start = this.pos, end = this.input.indexOf(&quot;*/&quot;, this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, &quot;Unterminated comment&quot;); }
  this.pos = end + 2;
  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;
    while ((match = lineBreakG.exec(this.input)) &amp;&amp; match.index &lt; this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    ++this.curLine;
    this.lineStart = this.pos;
  }
  break
case 47: // &apos;/&apos;
  switch (this.input.charCodeAt(this.pos + 1)) {
  case 42: // &apos;*&apos;
    this.<span class="apidocCodeKeywordSpan">skipBlockComment</span>();
    break
  case 47:
    this.skipLineComment(2);
    break
  default:
    break loop
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.skipLineComment" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.skipLineComment">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>skipLineComment
        <span class="apidocSignatureSpan">(startSkip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment &amp;&amp; this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos &lt; this.input.length &amp;&amp; !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// Labels in scope.
this.labels = [];
// Thus-far undefined exports.
this.undefinedExports = {};

// If enabled, skip leading hashbang line.
if (this.pos === 0 &amp;&amp; options.allowHashBang &amp;&amp; this.input.slice(0, 2) === &quot;#!&quot;)
  { this.<span class="apidocCodeKeywordSpan">skipLineComment</span>(2); }

// Scope tracking for duplicate variable names (see scope.js)
this.scopeStack = [];
this.enterScope(SCOPE_TOP);

// For RegExp validation
this.regexpState = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.skipSpace" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.skipSpace">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>skipSpace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  loop: while (this.pos &lt; this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
    case 32: case 160: // &apos; &apos;
      ++this.pos;
      break
    case 13:
      if (this.input.charCodeAt(this.pos + 1) === 10) {
        ++this.pos;
      }
    case 10: case 8232: case 8233:
      ++this.pos;
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      break
    case 47: // &apos;/&apos;
      switch (this.input.charCodeAt(this.pos + 1)) {
      case 42: // &apos;*&apos;
        this.skipBlockComment();
        break
      case 47:
        this.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch &gt; 8 &amp;&amp; ch &lt; 14 || ch &gt;= 5760 &amp;&amp; nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this.pos;
      } else {
        break loop
      }
    }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  };

  // Read a single token, updating the parser object&apos;s token-related
  // properties.

  pp$9.nextToken = function() {
var curContext = this.curContext();
if (!curContext || !curContext.preserveSpace) { this.<span class="apidocCodeKeywordSpan">skipSpace</span>(); }

this.start = this.pos;
if (this.options.locations) { this.startLoc = this.curPosition(); }
if (this.pos &gt;= this.input.length) { return this.finishToken(types.eof) }

if (curContext.override) { return curContext.override(this) }
else { this.readToken(this.fullCharCodeAtPos()); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.startNode" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.startNode">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>startNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return new Node(this, this.start, this.startLoc)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  // For RegExp validation
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },
allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.<span class="apidocCodeKeywordSpan">startNode</span>();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.startNodeAt" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.startNodeAt">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>startNodeAt
        <span class="apidocSignatureSpan">(pos, loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(pos, loc) {
  return new Node(this, pos, loc)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if ( noLineBreak === void 0 ) noLineBreak = false;

  var start = this$1.start, startLoc = this$1.startLoc;
  if (!this$1.eatContextual(k)) { return false }
  if (this$1.type !== types.parenL &amp;&amp; (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
  if (method.key) { this$1.unexpected(); }
  method.computed = false;
  method.key = this$1.<span class="apidocCodeKeywordSpan">startNodeAt</span>(start, startLoc);
  method.key.name = k;
  this$1.finishNode(method.key, &quot;Identifier&quot;);
  return false
};

method.kind = &quot;method&quot;;
method.static = tryContextual(&quot;static&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.strictDirective" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.strictDirective">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>strictDirective
        <span class="apidocSignatureSpan">(start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(start) {
  for (;;) {
    // Try to find string literal.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === &quot;use strict&quot;) { return true }
    start += match[0].length;

    // Skip semicolon, if any.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === &quot;;&quot;)
      { start++; }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// context to predict whether a regular expression is allowed in a
// given position.
this.context = this.initialContext();
this.exprAllowed = true;

// Figure out if it&apos;s a module code.
this.inModule = options.sourceType === &quot;module&quot;;
this.strict = this.inModule || this.<span class="apidocCodeKeywordSpan">strictDirective</span>(this.pos);

// Used to signify the start of a potential arrow function
this.potentialArrowAt = -1;

// Positions to delayed-check that yield/await does not exist in default parameters.
this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
// Labels in scope.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.toAssignable" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.toAssignable">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>toAssignable
        <span class="apidocSignatureSpan">(node, isBinding, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; node) {
    switch (node.type) {
    case &quot;Identifier&quot;:
      if (this.inAsync &amp;&amp; node.name === &quot;await&quot;)
        { this.raise(node.start, &quot;Cannot use &apos;await&apos; as identifier inside an async function&quot;); }
      break

    case &quot;ObjectPattern&quot;:
    case &quot;ArrayPattern&quot;:
    case &quot;RestElement&quot;:
      break

    case &quot;ObjectExpression&quot;:
      node.type = &quot;ObjectPattern&quot;;
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i &lt; list.length; i += 1) {
        var prop = list[i];

      this.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === &quot;RestElement&quot; &amp;&amp;
          (prop.argument.type === &quot;ArrayPattern&quot; || prop.argument.type === &quot;ObjectPattern&quot;)
        ) {
          this.raise(prop.argument.start, &quot;Unexpected token&quot;);
        }
      }
      break

    case &quot;Property&quot;:
      // AssignmentProperty has type === &quot;Property&quot;
      if (node.kind !== &quot;init&quot;) { this.raise(node.key.start, &quot;Object pattern can&apos;t contain getter or setter&quot;); }
      this.toAssignable(node.value, isBinding);
      break

    case &quot;ArrayExpression&quot;:
      node.type = &quot;ArrayPattern&quot;;
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case &quot;SpreadElement&quot;:
      node.type = &quot;RestElement&quot;;
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === &quot;AssignmentPattern&quot;)
        { this.raise(node.argument.start, &quot;Rest elements cannot have a default value&quot;); }
      break

    case &quot;AssignmentExpression&quot;:
      if (node.operator !== &quot;=&quot;) { this.raise(node.left.end, &quot;Only &apos;=&apos; operator can be used for specifying default value.&quot;); }
      node.type = &quot;AssignmentPattern&quot;;
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      // falls through to AssignmentPattern

    case &quot;AssignmentPattern&quot;:
      break

    case &quot;ParenthesizedExpression&quot;:
      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
      break

    case &quot;MemberExpression&quot;:
      if (!isBinding) { break }

    default:
      this.raise(node.start, &quot;Assigning to rvalue&quot;);
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
var init = this.parseExpression(true, refDestructuringErrors);
if (this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) {
  if (this.options.ecmaVersion &gt;= 9) {
    if (this.type === types._in) {
      if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
    } else { node.await = awaitAt &gt; -1; }
  }
  this.<span class="apidocCodeKeywordSpan">toAssignable</span>(init, false, refDestructuringErrors);
  this.checkLVal(init);
  return this.parseForIn(node, init)
} else {
  this.checkExpressionErrors(refDestructuringErrors, true);
}
if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
return this.parseFor(node, init)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.toAssignableList" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.toAssignableList">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>toAssignableList
        <span class="apidocSignatureSpan">(exprList, isBinding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i &lt; end; i++) {
    var elt = exprList[i];
    if (elt) { this.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 &amp;&amp; isBinding &amp;&amp; last &amp;&amp; last.type === &quot;RestElement&quot; &amp;&amp; last.argument.type !== &quot;Identifier
&quot;)
      { this.unexpected(last.argument.start); }
  }
  return exprList
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (node.kind !== &quot;init&quot;) { this.raise(node.key.start, &quot;Object pattern can&apos;t contain getter or setter&quot
;); }
  this.toAssignable(node.value, isBinding);
  break

case &quot;ArrayExpression&quot;:
  node.type = &quot;ArrayPattern&quot;;
  if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  this.<span class="apidocCodeKeywordSpan">toAssignableList</span>(node.elements, isBinding);
  break

case &quot;SpreadElement&quot;:
  node.type = &quot;RestElement&quot;;
  this.toAssignable(node.argument, isBinding);
  if (node.argument.type === &quot;AssignmentPattern&quot;)
    { this.raise(node.argument.start, &quot;Rest elements cannot have a default value&quot;); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.treatFunctionsAsVarInScope" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.treatFunctionsAsVarInScope">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>treatFunctionsAsVarInScope
        <span class="apidocSignatureSpan">(scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(scope) {
  return (scope.flags &amp; SCOPE_FUNCTION) || !this.inModule &amp;&amp; (scope.flags &amp; SCOPE_TOP)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_SUPER) &gt; 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.<span class="apidocCodeKeywordSpan">treatFunctionsAsVarInScope
</span>(this.currentScope()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags &amp; SCOPE_FUNCTION
) &gt; 0 };

Parser.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.tryReadTemplateToken" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.tryReadTemplateToken">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>tryReadTemplateToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

var types$1 = {
  b_stat: new TokContext(&quot;{&quot;, false),
  b_expr: new TokContext(&quot;{&quot;, true),
  b_tmpl: new TokContext(&quot;${&quot;, false),
  p_stat: new TokContext(&quot;(&quot;, false),
  p_expr: new TokContext(&quot;(&quot;, true),
  q_tmpl: new TokContext(&quot;`&quot;, true, true, function (p) { return p.<span class="apidocCodeKeywordSpan">tryReadTemplateToken
</span>(); }),
  f_stat: new TokContext(&quot;function&quot;, false),
  f_expr: new TokContext(&quot;function&quot;, true),
  f_expr_gen: new TokContext(&quot;function&quot;, true, false, null, true),
  f_gen: new TokContext(&quot;function&quot;, false, false, null, true)
};

var pp$7 = Parser.prototype;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.unexpected" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.unexpected">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>unexpected
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(pos) {
  this.raise(pos != null ? pos : this.start, &quot;Unexpected token&quot;);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.<span class="apidocCodeKeywordSpan">unexpected</span>(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.updateContext" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.updateContext">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>updateContext
        <span class="apidocSignatureSpan">(prevType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prevType) {
  var update, type = this.type;
  if (type.keyword &amp;&amp; prevType === types.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp$9.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.<span class="apidocCodeKeywordSpan">updateContext</span>(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.validateRegExpFlags" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.validateRegExpFlags">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>validateRegExpFlags
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i &lt; flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, &quot;Invalid regular expression flag&quot;);
    }
    if (flags.indexOf(flag, i + 1) &gt; -1) {
      this.raise(state.start, &quot;Duplicate regular expression flag&quot;);
    }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
var flagsStart = this.pos;
var flags = this.readWord1();
if (this.containsEsc) { this.unexpected(flagsStart); }

// Validate pattern
var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
state.reset(start, pattern, flags);
this.<span class="apidocCodeKeywordSpan">validateRegExpFlags</span>(state);
this.validateRegExpPattern(state);

// Create Literal#value property value.
var value = null;
try {
  value = new RegExp(pattern, flags);
} catch (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Parser.prototype.validateRegExpPattern" id="apidoc.elem.istanbul-lite.esprima.Parser.prototype.validateRegExpPattern">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Parser.prototype.</span>validateRegExpPattern
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN &amp;&amp; this.options.ecmaVersion &gt;= 9 &amp;&amp; state.groupNames.length &gt; 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
var flags = this.readWord1();
if (this.containsEsc) { this.unexpected(flagsStart); }

// Validate pattern
var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
state.reset(start, pattern, flags);
this.validateRegExpFlags(state);
this.<span class="apidocCodeKeywordSpan">validateRegExpPattern</span>(state);

// Create Literal#value property value.
var value = null;
try {
  value = new RegExp(pattern, flags);
} catch (e) {
  // ESTree requires null if it failed to instantiate RegExp object.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.esprima.Position" id="apidoc.module.istanbul-lite.esprima.Position">module istanbul-lite.esprima.Position</a></h1>


    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Position.Position" id="apidoc.elem.istanbul-lite.esprima.Position.Position">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.</span>Position
        <span class="apidocSignatureSpan">(line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Position(line, col) {
  this.line = line;
  this.column = col;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.esprima.Position.prototype" id="apidoc.module.istanbul-lite.esprima.Position.prototype">module istanbul-lite.esprima.Position.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.istanbul-lite.esprima.Position.prototype.offset" id="apidoc.elem.istanbul-lite.esprima.Position.prototype.offset">
        function <span class="apidocSignatureSpan">istanbul-lite.esprima.Position.prototype.</span>offset
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function offset (n) {
  return new Position(this.line, this.column + n)
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.estraverse" id="apidoc.module.istanbul-lite.estraverse">module istanbul-lite.estraverse</a></h1>


    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.Controller" id="apidoc.elem.istanbul-lite.estraverse.Controller">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.</span>Controller
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Controller() { }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.attachComments" id="apidoc.elem.istanbul-lite.estraverse.attachComments">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.</span>attachComments
        <span class="apidocSignatureSpan">(tree, providedComments, tokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attachComments(tree, providedComments, tokens) {
    // At first, we should calculate extended comment ranges.
    var comments = [], comment, len, i, cursor;

    if (!tree.range) {
        throw new Error(&apos;attachComments needs range information&apos;);
    }

    // tokens array is empty, we attach comments to tree as &apos;leadingComments&apos;
    if (!tokens.length) {
        if (providedComments.length) {
            for (i = 0, len = providedComments.length; i &lt; len; i += 1) {
                comment = deepCopy(providedComments[i]);
                comment.extendedRange = [0, tree.range[0]];
                comments.push(comment);
            }
            tree.leadingComments = comments;
        }
        return tree;
    }

    for (i = 0, len = providedComments.length; i &lt; len; i += 1) {
        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
    }

    // This is based on John Freeman&apos;s implementation.
    cursor = 0;
    traverse(tree, {
        enter: function (node) {
            var comment;

            while (cursor &lt; comments.length) {
                comment = comments[cursor];
                if (comment.extendedRange[1] &gt; node.range[0]) {
                    break;
                }

                if (comment.extendedRange[1] === node.range[0]) {
                    if (!node.leadingComments) {
                        node.leadingComments = [];
                    }
                    node.leadingComments.push(comment);
                    comments.splice(cursor, 1);
                } else {
                    cursor += 1;
                }
            }

            // already out of owned node
            if (cursor === comments.length) {
                return VisitorOption.Break;
            }

            if (comments[cursor].extendedRange[0] &gt; node.range[1]) {
                return VisitorOption.Skip;
            }
        }
    });

    cursor = 0;
    traverse(tree, {
        leave: function (node) {
            var comment;

            while (cursor &lt; comments.length) {
                comment = comments[cursor];
                if (node.range[1] &lt; comment.extendedRange[0]) {
                    break;
                }

                if (node.range[1] === comment.extendedRange[0]) {
                    if (!node.trailingComments) {
                        node.trailingComments = [];
                    }
                    node.trailingComments.push(comment);
                    comments.splice(cursor, 1);
                } else {
                    cursor += 1;
                }
            }

            // already out of owned node
            if (cursor === comments.length) {
                return VisitorOption.Break;
            }

            if (comments[cursor].extendedRange[0] &gt; node.range[1]) {
                return VisitorOption.Skip;
            }
        }
    });

    return tree;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.cloneEnvironment" id="apidoc.elem.istanbul-lite.estraverse.cloneEnvironment">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.</span>cloneEnvironment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cloneEnvironment = function () { return clone({}); }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.replace" id="apidoc.elem.istanbul-lite.estraverse.replace">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.</span>replace
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replace(root, visitor) {
    var controller = new Controller();
    return controller.replace(root, visitor);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            recursive: true
        });
        // re-write pathname
        fs.writeFileSync(pathname, data);
        success = true;
    }
    if (success &amp;&amp; msg) {
        console.error(msg.<span class="apidocCodeKeywordSpan">replace</span>(&quot;{{pathname}}&quot;, pathname));
    }
    return success;
};
local.identity = function (val) {
/*
 * this function will return &lt;val&gt;
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.traverse" id="apidoc.elem.istanbul-lite.estraverse.traverse">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.</span>traverse
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function traverse(root, visitor) {
    var controller = new Controller();
    return controller.traverse(root, visitor);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    }

    return outer.root;
};

function traverse(root, visitor) {
    var controller = new Controller();
    return controller.<span class="apidocCodeKeywordSpan">traverse</span>(root, visitor);
}

function replace(root, visitor) {
    var controller = new Controller();
    return controller.replace(root, visitor);
}
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.estraverse.Controller" id="apidoc.module.istanbul-lite.estraverse.Controller">module istanbul-lite.estraverse.Controller</a></h1>


    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.Controller.Controller" id="apidoc.elem.istanbul-lite.estraverse.Controller.Controller">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.</span>Controller
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Controller() { }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.estraverse.Controller.prototype" id="apidoc.module.istanbul-lite.estraverse.Controller.prototype">module istanbul-lite.estraverse.Controller.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.__execute" id="apidoc.elem.istanbul-lite.estraverse.Controller.prototype.__execute">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>__execute
        <span class="apidocSignatureSpan">(callback, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function __execute(callback, element) {
    var previous, result;

    result = undefined;

    previous  = this.__current;
    this.__current = element;
    this.__state = null;
    if (callback) {
        result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
    }
    this.__current = previous;

    return result;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

        while (worklist.length) {
element = worklist.pop();

if (element === sentinel) {
    element = leavelist.pop();

    ret = this.<span class="apidocCodeKeywordSpan">__execute</span>(visitor.leave, element);

    if (this.__state === BREAK || ret === BREAK) {
        return;
    }
    continue;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.__initialize" id="apidoc.elem.istanbul-lite.estraverse.Controller.prototype.__initialize">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>__initialize
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(root, visitor) {
    this.visitor = visitor;
    this.root = root;
    this.__worklist = [];
    this.__leavelist = [];
    this.__current = null;
    this.__state = null;
    this.__fallback = null;
    if (visitor.fallback === &apos;iteration&apos;) {
        this.__fallback = objectKeys;
    } else if (typeof visitor.fallback === &apos;function&apos;) {
        this.__fallback = visitor.fallback;
    }

    this.__keys = VisitorKeys;
    if (visitor.keys) {
        this.__keys = extend(objectCreate(this.__keys), visitor.keys);
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    key,
    current,
    current2,
    candidates,
    candidate,
    sentinel;

this.<span class="apidocCodeKeywordSpan">__initialize</span>(root, visitor);

sentinel = {};

// reference
worklist = this.__worklist;
leavelist = this.__leavelist;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.break" id="apidoc.elem.istanbul-lite.estraverse.Controller.prototype.break">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">break = function () {
    this.notify(BREAK);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.current" id="apidoc.elem.istanbul-lite.estraverse.Controller.prototype.current">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>current
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function current() {
    return this.__current.node;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

RegExpValidationState.prototype.advance = function advance () {
  this.pos = this.nextIndex(this.pos);
};

RegExpValidationState.prototype.eat = function eat (ch) {
  if (this.<span class="apidocCodeKeywordSpan">current</span>() === ch) {
    this.advance();
    return true
  }
  return false
};

function codePointToString(ch) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.notify" id="apidoc.elem.istanbul-lite.estraverse.Controller.prototype.notify">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>notify
        <span class="apidocSignatureSpan">(flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notify(flag) {
    this.__state = flag;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
Controller.prototype.notify = function notify(flag) {
    this.__state = flag;
};

// API:
// skip child nodes of current node
Controller.prototype.skip = function () {
    this.<span class="apidocCodeKeywordSpan">notify</span>(SKIP);
};

// API:
// break traversals
Controller.prototype[&apos;break&apos;] = function () {
    this.notify(BREAK);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.parents" id="apidoc.elem.istanbul-lite.estraverse.Controller.prototype.parents">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>parents
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parents() {
    var i, iz, result;

    // first node is sentinel
    result = [];
    for (i = 1, iz = this.__leavelist.length; i &lt; iz; ++i) {
        result.push(this.__leavelist[i].node);
    }

    return result;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.path" id="apidoc.elem.istanbul-lite.estraverse.Controller.prototype.path">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>path
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function path() {
    var i, iz, j, jz, result, element;

    function addToPath(result, path) {
        if (isArray(path)) {
            for (j = 0, jz = path.length; j &lt; jz; ++j) {
                result.push(path[j]);
            }
        } else {
            result.push(path);
        }
    }

    // root node
    if (!this.__current.path) {
        return null;
    }

    // first node is sentinel, second node is root element
    result = [];
    for (i = 2, iz = this.__leavelist.length; i &lt; iz; ++i) {
        element = this.__leavelist[i];
        addToPath(result, element.path);
    }
    addToPath(result, this.__current.path);
    return result;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.remove" id="apidoc.elem.istanbul-lite.estraverse.Controller.prototype.remove">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>remove
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function () {
    this.notify(REMOVE);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

        function removeElem(element) {
            var i,
key,
nextElem,
parent;

            if (element.ref.<span class="apidocCodeKeywordSpan">remove</span>()) {
// When the reference is an element of an array.
key = element.ref.key;
parent = element.ref.parent;

// If removed from array, then decrease following items&apos; keys.
i = worklist.length;
while (i--) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.replace" id="apidoc.elem.istanbul-lite.estraverse.Controller.prototype.replace">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>replace
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replace(root, visitor) {
    var worklist,
        leavelist,
        node,
        nodeType,
        target,
        element,
        current,
        current2,
        candidates,
        candidate,
        sentinel,
        outer,
        key;

    function removeElem(element) {
        var i,
            key,
            nextElem,
            parent;

        if (element.ref.remove()) {
            // When the reference is an element of an array.
            key = element.ref.key;
            parent = element.ref.parent;

            // If removed from array, then decrease following items&apos; keys.
            i = worklist.length;
            while (i--) {
                nextElem = worklist[i];
                if (nextElem.ref &amp;&amp; nextElem.ref.parent === parent) {
                    if  (nextElem.ref.key &lt; key) {
                        break;
                    }
                    --nextElem.ref.key;
                }
            }
        }
    }

    this.__initialize(root, visitor);

    sentinel = {};

    // reference
    worklist = this.__worklist;
    leavelist = this.__leavelist;

    // initialize
    outer = {
        root: root
    };
    element = new Element(root, null, null, new Reference(outer, &apos;root&apos;));
    worklist.push(element);
    leavelist.push(element);

    while (worklist.length) {
        element = worklist.pop();

        if (element === sentinel) {
            element = leavelist.pop();

            target = this.__execute(visitor.leave, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined &amp;&amp; target !== BREAK &amp;&amp; target !== SKIP &amp;&amp; target !== REMOVE) {
                // replace
                element.ref.replace(target);
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }
            continue;
        }

        target = this.__execute(visitor.enter, element);

        // node may be replaced with null,
        // so distinguish between undefined and null in this place
        if (target !== undefined &amp;&amp; target !== BREAK &amp;&amp; target !== SKIP &amp;&amp; target !== REMOVE) {
            // replace
            element.ref.replace(target);
            element.node = target;
        }

        if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
            element.node = null;
        }

        if (this.__state === BREAK || target === BREAK) {
            return outer.root;
        }

        // node may be null
        node = element.node;
        if (!node) {
            continue;
        }

        worklist.push(sentinel);
        leavelist.push(element);

        if (this.__state === SKIP || target === SKIP) {
            continue;
        }

        nodeType = node.type || element.wrap;
        candidates = this.__keys[nodeType];
        if (!candidates) {
            if (this.__fallback) {
                candidates = this.__fallback(node);
            } else {
                throw new Error(&apos;Unknown node type &apos; + nodeType + &apos;.&apos;);
            }
        }

        current = candidates.length;
        while ((current -= 1) &gt;= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
                continue;
            }

            if (isArray(candidate)) {
                current2 = candidate.length;
                while ((current2 -= 1) &gt;= 0) {
                    if (!candidate[current2]) {
                        continue;
                    }
                    if (isProperty(nodeType, candidates[current])) {
                        element = new Element(candidate[current2], [key, current2], &apos;Property&apos;, new Reference(candidate, current2
));
                    } else if (isNode(candidat...</pre></li>
    <li>example use<pre class="apidocCodePre">...
            recursive: true
        });
        // re-write pathname
        fs.writeFileSync(pathname, data);
        success = true;
    }
    if (success &amp;&amp; msg) {
        console.error(msg.<span class="apidocCodeKeywordSpan">replace</span>(&quot;{{pathname}}&quot;, pathname));
    }
    return success;
};
local.identity = function (val) {
/*
 * this function will return &lt;val&gt;
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.skip" id="apidoc.elem.istanbul-lite.estraverse.Controller.prototype.skip">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>skip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function () {
    this.notify(SKIP);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.traverse" id="apidoc.elem.istanbul-lite.estraverse.Controller.prototype.traverse">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>traverse
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function traverse(root, visitor) {
    var worklist,
        leavelist,
        element,
        node,
        nodeType,
        ret,
        key,
        current,
        current2,
        candidates,
        candidate,
        sentinel;

    this.__initialize(root, visitor);

    sentinel = {};

    // reference
    worklist = this.__worklist;
    leavelist = this.__leavelist;

    // initialize
    worklist.push(new Element(root, null, null, null));
    leavelist.push(new Element(null, null, null, null));

    while (worklist.length) {
        element = worklist.pop();

        if (element === sentinel) {
            element = leavelist.pop();

            ret = this.__execute(visitor.leave, element);

            if (this.__state === BREAK || ret === BREAK) {
                return;
            }
            continue;
        }

        if (element.node) {

            ret = this.__execute(visitor.enter, element);

            if (this.__state === BREAK || ret === BREAK) {
                return;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || ret === SKIP) {
                continue;
            }

            node = element.node;
            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = this.__fallback(node);
                } else {
                    throw new Error(&apos;Unknown node type &apos; + nodeType + &apos;.&apos;);
                }
            }

            current = candidates.length;
            while ((current -= 1) &gt;= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) &gt;= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], &apos;Property&apos;, null);
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, null);
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, null));
                }
            }
        }
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    }

    return outer.root;
};

function traverse(root, visitor) {
    var controller = new Controller();
    return controller.<span class="apidocCodeKeywordSpan">traverse</span>(root, visitor);
}

function replace(root, visitor) {
    var controller = new Controller();
    return controller.replace(root, visitor);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.estraverse.Controller.prototype.type" id="apidoc.elem.istanbul-lite.estraverse.Controller.prototype.type">
        function <span class="apidocSignatureSpan">istanbul-lite.estraverse.Controller.prototype.</span>type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">type = function () {
    var node = this.current();
    return node.type || this.__current.wrap;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.process" id="apidoc.module.istanbul-lite.process">module istanbul-lite.process</a></h1>




    <h2>
        <a href="#apidoc.elem.istanbul-lite.process._debugEnd" id="apidoc.elem.istanbul-lite.process._debugEnd">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_debugEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _debugEnd() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process._debugProcess" id="apidoc.elem.istanbul-lite.process._debugProcess">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_debugProcess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _debugProcess() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process._fatalException" id="apidoc.elem.istanbul-lite.process._fatalException">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_fatalException
        <span class="apidocSignatureSpan">(er, fromPromise)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(er, fromPromise) =&gt; {
  // It&apos;s possible that defaultTriggerAsyncId was set for a constructor
  // call that threw and was never cleared. So clear it now.
  clearDefaultTriggerAsyncId();

  // If diagnostic reporting is enabled, call into its handler to see
  // whether it is interested in handling the situation.
  // Ignore if the error is scoped inside a domain.
  // use == in the checks as we want to allow for null and undefined
  if (er == null || er.domain == null) {
    try {
      const report = internalBinding(&apos;report&apos;);
      if (report != null &amp;&amp; report.shouldReportOnUncaughtException()) {
        report.writeReport(er ? er.message : &apos;Exception&apos;,
                           &apos;Exception&apos;,
                           null,
                           er ? er.stack : undefined);
      }
    } catch {}  // Ignore the exception. Diagnostic reporting is unavailable.
  }

  const type = fromPromise ? &apos;unhandledRejection&apos; : &apos;uncaughtException&apos;;
  process.emit(&apos;uncaughtExceptionMonitor&apos;, er, type);
  if (exceptionHandlerState.captureFn !== null) {
    exceptionHandlerState.captureFn(er);
  } else if (!process.emit(&apos;uncaughtException&apos;, er, type)) {
    // If someone handled it, then great. Otherwise, die in C++ land
    // since that means that we&apos;ll exit the process, emit the &apos;exit&apos; event.
    try {
      if (!process._exiting) {
        process._exiting = true;
        process.exitCode = 1;
        process.emit(&apos;exit&apos;, 1);
      }
    } catch {
      // Nothing to be done about it at this point.
    }
    return false;
  }

  // If we handled an error, then make sure any ticks get processed
  // by ensuring that the next Immediate cycle isn&apos;t empty.
  require(&apos;timers&apos;).setImmediate(noop);

  // Emit the after() hooks now that the exception has been handled.
  if (afterHooksExist()) {
    do {
      emitAfter(executionAsyncId());
    } while (hasAsyncIdStack());
  // Or completely empty the id stack.
  } else {
    clearAsyncIdStack();
  }

  return true;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process._getActiveHandles" id="apidoc.elem.istanbul-lite.process._getActiveHandles">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_getActiveHandles
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _getActiveHandles() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process._getActiveRequests" id="apidoc.elem.istanbul-lite.process._getActiveRequests">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_getActiveRequests
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _getActiveRequests() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process._kill" id="apidoc.elem.istanbul-lite.process._kill">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_kill
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _kill() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process._linkedBinding" id="apidoc.elem.istanbul-lite.process._linkedBinding">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_linkedBinding
        <span class="apidocSignatureSpan">(module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _linkedBinding(module) {
  module = String(module);
  let mod = bindingObj[module];
  if (typeof mod !== &apos;object&apos;)
    mod = bindingObj[module] = getLinkedBinding(module);
  return mod;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process._rawDebug" id="apidoc.elem.istanbul-lite.process._rawDebug">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_rawDebug
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _rawDebug(...args) {
  binding._rawDebug(format.apply(null, args));
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process._startProfilerIdleNotifier" id="apidoc.elem.istanbul-lite.process._startProfilerIdleNotifier">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_startProfilerIdleNotifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _startProfilerIdleNotifier() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process._stopProfilerIdleNotifier" id="apidoc.elem.istanbul-lite.process._stopProfilerIdleNotifier">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_stopProfilerIdleNotifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _stopProfilerIdleNotifier() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process._tickCallback" id="apidoc.elem.istanbul-lite.process._tickCallback">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>_tickCallback
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runNextTicks() {
  if (!hasTickScheduled() &amp;&amp; !hasRejectionToWarn())
    runMicrotasks();
  if (!hasTickScheduled() &amp;&amp; !hasRejectionToWarn())
    return;

  processTicksAndRejections();
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.abort" id="apidoc.elem.istanbul-lite.process.abort">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>abort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function abort() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.assert" id="apidoc.elem.istanbul-lite.process.assert">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>assert
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecated(...args) {
  if (!warned) {
    warned = true;
    if (code !== undefined) {
      if (!codesWarned.has(code)) {
        process.emitWarning(msg, &apos;DeprecationWarning&apos;, code, deprecated);
        codesWarned.add(code);
      }
    } else {
      process.emitWarning(msg, &apos;DeprecationWarning&apos;, deprecated);
    }
  }
  if (new.target) {
    return ReflectConstruct(fn, args, new.target);
  }
  return fn.apply(this, args);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
}
static defaultMatrix() {
    return new THREE.Matrix4();
}
}
var aa = new SkinnedMesh();
aa.update();
console.<span class="apidocCodeKeywordSpan">assert</span>(aa.boneCount === 0);
aa.matrixType = &apos;defaultMatrix&apos;;
console.assert(aa.matrixType === undefined);
});
tryCatch(function () {
var handler, theProtoObj;
var obj = {
// __proto__
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.binding" id="apidoc.elem.istanbul-lite.process.binding">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>binding
        <span class="apidocSignatureSpan">(module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function binding(module) {
  module = String(module);
  // Deprecated specific process.binding() modules, but not all, allow
  // selective fallback to internalBinding for the deprecated ones.
  if (internalBindingWhitelist.has(module)) {
    return internalBinding(module);
  }
  // eslint-disable-next-line no-restricted-syntax
  throw new Error(`No such module: ${module}`);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.chdir" id="apidoc.elem.istanbul-lite.process.chdir">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>chdir
        <span class="apidocSignatureSpan">(directory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrappedChdir(directory) {
  validateString(directory, &apos;directory&apos;);
  rawMethods.chdir(directory);
  // Mark cache that it requires an update.
  cachedCwd = &apos;&apos;;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.cpuUsage" id="apidoc.elem.istanbul-lite.process.cpuUsage">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>cpuUsage
        <span class="apidocSignatureSpan">(prevValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuUsage(prevValue) {
  // If a previous value was passed in, ensure it has the correct shape.
  if (prevValue) {
    if (!previousValueIsValid(prevValue.user)) {
      if (typeof prevValue !== &apos;object&apos;)
        throw new ERR_INVALID_ARG_TYPE(&apos;prevValue&apos;, &apos;object&apos;, prevValue);

      if (typeof prevValue.user !== &apos;number&apos;) {
        throw new ERR_INVALID_ARG_TYPE(&apos;prevValue.user&apos;,
                                       &apos;number&apos;, prevValue.user);
      }
      throw new ERR_INVALID_OPT_VALUE.RangeError(&apos;prevValue.user&apos;,
                                                 prevValue.user);
    }

    if (!previousValueIsValid(prevValue.system)) {
      if (typeof prevValue.system !== &apos;number&apos;) {
        throw new ERR_INVALID_ARG_TYPE(&apos;prevValue.system&apos;,
                                       &apos;number&apos;, prevValue.system);
      }
      throw new ERR_INVALID_OPT_VALUE.RangeError(&apos;prevValue.system&apos;,
                                                 prevValue.system);
    }
  }

  // Call the native function to get the current values.
  const errmsg = _cpuUsage(cpuValues);
  if (errmsg) {
    throw new ERR_CPU_USAGE(errmsg);
  }

  // If a previous value was passed in, return diff of current from previous.
  if (prevValue) {
    return {
      user: cpuValues[0] - prevValue.user,
      system: cpuValues[1] - prevValue.system
    };
  }

  // If no previous value passed in, return current value.
  return {
    user: cpuValues[0],
    system: cpuValues[1]
  };
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.cwd" id="apidoc.elem.istanbul-lite.process.cwd">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>cwd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrappedCwd() {
  if (cachedCwd === &apos;&apos;)
    cachedCwd = rawMethods.cwd();
  return cachedCwd;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
[![apidoc](https://kaizhu256.github.io/node-istanbul-lite/build/screenshot.buildCi.browser.%252Ftmp%252Fbuild%252Fapidoc.html.png
)](https://kaizhu256.github.io/node-istanbul-lite/build..beta..travis-ci.org/apidoc.html)

#### cli help
![screenshot](https://kaizhu256.github.io/node-istanbul-lite/build/screenshot.npmPackageCliHelp.svg)

#### changelog 2020.5.31
- npm publish 2020.5.31
- replace process.<span class="apidocCodeKeywordSpan">cwd</span>() with path.resolve()
- replace function fsReadFileOrEmptyStringSync with fsReadFileOrDefaultSync
- remove dependency to file lib.swgg.js
- istanbul - inline function templateRender
- none

#### todo
- istanbul - inline function templateRender
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.dlopen" id="apidoc.elem.istanbul-lite.process.dlopen">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>dlopen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dlopen() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.emitWarning" id="apidoc.elem.istanbul-lite.process.emitWarning">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>emitWarning
        <span class="apidocSignatureSpan">(warning, type, code, ctor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitWarning(warning, type, code, ctor) {
  let detail;
  if (type !== null &amp;&amp; typeof type === &apos;object&apos; &amp;&amp; !ArrayIsArray(type)) {
    ctor = type.ctor;
    code = type.code;
    if (typeof type.detail === &apos;string&apos;)
      detail = type.detail;
    type = type.type || &apos;Warning&apos;;
  } else if (typeof type === &apos;function&apos;) {
    ctor = type;
    code = undefined;
    type = &apos;Warning&apos;;
  }
  if (type !== undefined &amp;&amp; typeof type !== &apos;string&apos;) {
    throw new ERR_INVALID_ARG_TYPE(&apos;type&apos;, &apos;string&apos;, type);
  }
  if (typeof code === &apos;function&apos;) {
    ctor = code;
    code = undefined;
  } else if (code !== undefined &amp;&amp; typeof code !== &apos;string&apos;) {
    throw new ERR_INVALID_ARG_TYPE(&apos;code&apos;, &apos;string&apos;, code);
  }
  if (typeof warning === &apos;string&apos;) {
    warning = createWarningObject(warning, type, code, ctor, detail);
  } else if (!(warning instanceof Error)) {
    throw new ERR_INVALID_ARG_TYPE(&apos;warning&apos;, [&apos;Error&apos;, &apos;string&apos;], warning);
  }
  if (warning.name === &apos;DeprecationWarning&apos;) {
    if (process.noDeprecation)
      return;
    if (process.throwDeprecation)
      throw warning;
  }
  process.nextTick(doEmitWarning, warning);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.exit" id="apidoc.elem.istanbul-lite.process.exit">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>exit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exit = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.getegid" id="apidoc.elem.istanbul-lite.process.getegid">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>getegid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getegid() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.geteuid" id="apidoc.elem.istanbul-lite.process.geteuid">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>geteuid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function geteuid() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.getgid" id="apidoc.elem.istanbul-lite.process.getgid">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>getgid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getgid() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.getgroups" id="apidoc.elem.istanbul-lite.process.getgroups">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>getgroups
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getgroups() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.getuid" id="apidoc.elem.istanbul-lite.process.getuid">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>getuid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getuid() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.hasUncaughtExceptionCaptureCallback" id="apidoc.elem.istanbul-lite.process.hasUncaughtExceptionCaptureCallback">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>hasUncaughtExceptionCaptureCallback
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasUncaughtExceptionCaptureCallback() {
  return exceptionHandlerState.captureFn !== null;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.hrtime" id="apidoc.elem.istanbul-lite.process.hrtime">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>hrtime
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hrtime(time) {
  _hrtime(hrValues);

  if (time !== undefined) {
    if (!ArrayIsArray(time)) {
      throw new ERR_INVALID_ARG_TYPE(&apos;time&apos;, &apos;Array&apos;, time);
    }
    if (time.length !== 2) {
      throw new ERR_OUT_OF_RANGE(&apos;time&apos;, 2, time.length);
    }

    const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];
    const nsec = hrValues[2] - time[1];
    const needsBorrow = nsec &lt; 0;
    return [needsBorrow ? sec - 1 : sec, needsBorrow ? nsec + 1e9 : nsec];
  }

  return [
    hrValues[0] * 0x100000000 + hrValues[1],
    hrValues[2]
  ];
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.initgroups" id="apidoc.elem.istanbul-lite.process.initgroups">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>initgroups
        <span class="apidocSignatureSpan">(user, extraGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initgroups(user, extraGroup) {
  validateId(user, &apos;user&apos;);
  validateId(extraGroup, &apos;extraGroup&apos;);
  // Result is 0 on success, 1 if user is unknown, 2 if group is unknown.
  const result = _initgroups(user, extraGroup);
  if (result === 1) {
    throw new ERR_UNKNOWN_CREDENTIAL(&apos;User&apos;, user);
  } else if (result === 2) {
    throw new ERR_UNKNOWN_CREDENTIAL(&apos;Group&apos;, extraGroup);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.kill" id="apidoc.elem.istanbul-lite.process.kill">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>kill
        <span class="apidocSignatureSpan">(pid, sig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kill(pid, sig) {
  let err;

  // eslint-disable-next-line eqeqeq
  if (pid != (pid | 0)) {
    throw new ERR_INVALID_ARG_TYPE(&apos;pid&apos;, &apos;number&apos;, pid);
  }

  // Preserve null signal
  if (sig === (sig | 0)) {
    // XXX(joyeecheung): we have to use process._kill here because
    // it&apos;s monkey-patched by tests.
    err = process._kill(pid, sig);
  } else {
    sig = sig || &apos;SIGTERM&apos;;
    if (constants[sig]) {
      err = process._kill(pid, constants[sig]);
    } else {
      throw new ERR_UNKNOWN_SIGNAL(sig);
    }
  }

  if (err)
    throw errnoException(err, &apos;kill&apos;);

  return true;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.memoryUsage" id="apidoc.elem.istanbul-lite.process.memoryUsage">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>memoryUsage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function memoryUsage() {
  _memoryUsage(memValues);
  return {
    rss: memValues[0],
    heapTotal: memValues[1],
    heapUsed: memValues[2],
    external: memValues[3],
    arrayBuffers: memValues[4]
  };
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.nextTick" id="apidoc.elem.istanbul-lite.process.nextTick">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>nextTick
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(callback) {
  if (typeof callback !== &apos;function&apos;)
    throw new ERR_INVALID_CALLBACK(callback);

  if (process._exiting)
    return;

  let args;
  switch (arguments.length) {
    case 1: break;
    case 2: args = [arguments[1]]; break;
    case 3: args = [arguments[1], arguments[2]]; break;
    case 4: args = [arguments[1], arguments[2], arguments[3]]; break;
    default:
      args = new Array(arguments.length - 1);
      for (let i = 1; i &lt; arguments.length; i++)
        args[i - 1] = arguments[i];
  }

  if (queue.isEmpty())
    setHasTickScheduled(true);
  const asyncId = newAsyncId();
  const triggerAsyncId = getDefaultTriggerAsyncId();
  const tickObject = {
    [async_id_symbol]: asyncId,
    [trigger_async_id_symbol]: triggerAsyncId,
    callback,
    args
  };
  if (initHooksExist())
    emitInit(asyncId, &apos;TickObject&apos;, triggerAsyncId, tickObject);
  queue.push(tickObject);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.openStdin" id="apidoc.elem.istanbul-lite.process.openStdin">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>openStdin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  process.stdin.resume();
  return process.stdin;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.reallyExit" id="apidoc.elem.istanbul-lite.process.reallyExit">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>reallyExit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reallyExit() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.resourceUsage" id="apidoc.elem.istanbul-lite.process.resourceUsage">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>resourceUsage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resourceUsage() {
  _resourceUsage(resourceValues);
  return {
    userCPUTime: resourceValues[0],
    systemCPUTime: resourceValues[1],
    maxRSS: resourceValues[2],
    sharedMemorySize: resourceValues[3],
    unsharedDataSize: resourceValues[4],
    unsharedStackSize: resourceValues[5],
    minorPageFault: resourceValues[6],
    majorPageFault: resourceValues[7],
    swappedOut: resourceValues[8],
    fsRead: resourceValues[9],
    fsWrite: resourceValues[10],
    ipcSent: resourceValues[11],
    ipcReceived: resourceValues[12],
    signalsCount: resourceValues[13],
    voluntaryContextSwitches: resourceValues[14],
    involuntaryContextSwitches: resourceValues[15]
  };
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.setUncaughtExceptionCaptureCallback" id="apidoc.elem.istanbul-lite.process.setUncaughtExceptionCaptureCallback">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>setUncaughtExceptionCaptureCallback
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(fn) {
  const err = new ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE();
  err.stack = err.stack + &apos;\n&apos; + &apos;-&apos;.repeat(40) + &apos;\n&apos; + domainRequireStack;
  throw err;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.setegid" id="apidoc.elem.istanbul-lite.process.setegid">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>setegid
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  validateId(id, &apos;id&apos;);
  // Result is 0 on success, 1 if credential is unknown.
  const result = method(id);
  if (result === 1) {
    throw new ERR_UNKNOWN_CREDENTIAL(type, id);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.seteuid" id="apidoc.elem.istanbul-lite.process.seteuid">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>seteuid
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  validateId(id, &apos;id&apos;);
  // Result is 0 on success, 1 if credential is unknown.
  const result = method(id);
  if (result === 1) {
    throw new ERR_UNKNOWN_CREDENTIAL(type, id);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.setgid" id="apidoc.elem.istanbul-lite.process.setgid">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>setgid
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  validateId(id, &apos;id&apos;);
  // Result is 0 on success, 1 if credential is unknown.
  const result = method(id);
  if (result === 1) {
    throw new ERR_UNKNOWN_CREDENTIAL(type, id);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.setgroups" id="apidoc.elem.istanbul-lite.process.setgroups">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>setgroups
        <span class="apidocSignatureSpan">(groups)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setgroups(groups) {
  if (!ArrayIsArray(groups)) {
    throw new ERR_INVALID_ARG_TYPE(&apos;groups&apos;, &apos;Array&apos;, groups);
  }
  for (let i = 0; i &lt; groups.length; i++) {
    validateId(groups[i], `groups[${i}]`);
  }
  // Result is 0 on success. A positive integer indicates that the
  // corresponding group was not found.
  const result = _setgroups(groups);
  if (result &gt; 0) {
    throw new ERR_UNKNOWN_CREDENTIAL(&apos;Group&apos;, groups[result - 1]);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.setuid" id="apidoc.elem.istanbul-lite.process.setuid">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>setuid
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  validateId(id, &apos;id&apos;);
  // Result is 0 on success, 1 if credential is unknown.
  const result = method(id);
  if (result === 1) {
    throw new ERR_UNKNOWN_CREDENTIAL(type, id);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.umask" id="apidoc.elem.istanbul-lite.process.umask">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>umask
        <span class="apidocSignatureSpan">(mask)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrappedUmask(mask) {
  if (mask !== undefined) {
    mask = parseFileMode(mask, &apos;mask&apos;);
  }
  return rawMethods.umask(mask);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.uptime" id="apidoc.elem.istanbul-lite.process.uptime">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>uptime
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function uptime() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>




















































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.process._events" id="apidoc.module.istanbul-lite.process._events">module istanbul-lite.process._events</a></h1>


    <h2>
        <a href="#apidoc.elem.istanbul-lite.process._events.warning" id="apidoc.elem.istanbul-lite.process._events.warning">
        function <span class="apidocSignatureSpan">istanbul-lite.process._events.</span>warning
        <span class="apidocSignatureSpan">(warning)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onWarning(warning) {
  if (!(warning instanceof Error)) return;
  const isDeprecation = warning.name === &apos;DeprecationWarning&apos;;
  if (isDeprecation &amp;&amp; process.noDeprecation) return;
  const trace = process.traceProcessWarnings ||
                (isDeprecation &amp;&amp; process.traceDeprecation);
  let msg = `(${process.release.name}:${process.pid}) `;
  if (warning.code)
    msg += `[${warning.code}] `;
  if (trace &amp;&amp; warning.stack) {
    msg += `${warning.stack}`;
  } else {
    const toString =
      typeof warning.toString === &apos;function&apos; ?
        warning.toString : Error.prototype.toString;
    msg += `${toString.apply(warning)}`;
  }
  if (typeof warning.detail === &apos;string&apos;) {
    msg += `\n${warning.detail}`;
  }
  if (!trace &amp;&amp; !traceWarningHelperShown) {
    const flag = isDeprecation ? &apos;--trace-deprecation&apos; : &apos;--trace-warnings&apos;;
    const argv0 = require(&apos;path&apos;).basename(process.argv0 || &apos;node&apos;, &apos;.exe&apos;);
    msg += `\n(Use \`${argv0} ${flag} ...\` to show where the warning ` +
           &apos;was created)&apos;;
    traceWarningHelperShown = true;
  }
  const warningFile = lazyOption();
  if (warningFile) {
    return writeToFile(msg);
  }
  writeOut(msg);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.process.hrtime" id="apidoc.module.istanbul-lite.process.hrtime">module istanbul-lite.process.hrtime</a></h1>


    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.hrtime.hrtime" id="apidoc.elem.istanbul-lite.process.hrtime.hrtime">
        function <span class="apidocSignatureSpan">istanbul-lite.process.</span>hrtime
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hrtime(time) {
  _hrtime(hrValues);

  if (time !== undefined) {
    if (!ArrayIsArray(time)) {
      throw new ERR_INVALID_ARG_TYPE(&apos;time&apos;, &apos;Array&apos;, time);
    }
    if (time.length !== 2) {
      throw new ERR_OUT_OF_RANGE(&apos;time&apos;, 2, time.length);
    }

    const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];
    const nsec = hrValues[2] - time[1];
    const needsBorrow = nsec &lt; 0;
    return [needsBorrow ? sec - 1 : sec, needsBorrow ? nsec + 1e9 : nsec];
  }

  return [
    hrValues[0] * 0x100000000 + hrValues[1],
    hrValues[2]
  ];
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.hrtime.bigint" id="apidoc.elem.istanbul-lite.process.hrtime.bigint">
        function <span class="apidocSignatureSpan">istanbul-lite.process.hrtime.</span>bigint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hrtimeBigInt() {
  _hrtimeBigInt(hrBigintValues);
  return hrBigintValues[0];
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.process.stderr" id="apidoc.module.istanbul-lite.process.stderr">module istanbul-lite.process.stderr</a></h1>










    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.stderr._destroy" id="apidoc.elem.istanbul-lite.process.stderr._destroy">
        function <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>_destroy
        <span class="apidocSignatureSpan">(err, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dummyDestroy(err, cb) {
  cb(err);

  // We need to emit &apos;close&apos; anyway so that the closing
  // of the stream is observable. We just make sure we
  // are not going to do it twice.
  // The &apos;close&apos; event is needed so that finished and
  // pipeline work correctly.
  if (!this._writableState.emitClose) {
    process.nextTick(() =&gt; {
      this.emit(&apos;close&apos;);
    });
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.stderr.destroySoon" id="apidoc.elem.istanbul-lite.process.stderr.destroySoon">
        function <span class="apidocSignatureSpan">istanbul-lite.process.stderr.</span>destroySoon
        <span class="apidocSignatureSpan">(err, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroy(err, cb) {
  const r = this._readableState;
  const w = this._writableState;

  if ((w &amp;&amp; w.destroyed) || (r &amp;&amp; r.destroyed)) {
    if (typeof cb === &apos;function&apos;) {
      cb();
    }

    return this;
  }

  if (err) {
    if (w) {
      w.errored = true;
    }
    if (r) {
      r.errored = true;
    }
  }

  // We set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (w) {
    w.destroyed = true;
  }
  if (r) {
    r.destroyed = true;
  }

  this._destroy(err || null, (err) =&gt; {
    if (err) {
      if (w) {
        w.errored = true;
      }
      if (r) {
        r.errored = true;
      }
    }

    if (w) {
      w.closed = true;
    }
    if (r) {
      r.closed = true;
    }

    if (typeof cb === &apos;function&apos;) {
      cb(err);
    }

    if (err) {
      process.nextTick(emitErrorCloseNT, this, err);
    } else {
      process.nextTick(emitCloseNT, this);
    }
  });

  return this;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>




























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.process.stdout" id="apidoc.module.istanbul-lite.process.stdout">module istanbul-lite.process.stdout</a></h1>










    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.stdout._destroy" id="apidoc.elem.istanbul-lite.process.stdout._destroy">
        function <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>_destroy
        <span class="apidocSignatureSpan">(err, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dummyDestroy(err, cb) {
  cb(err);

  // We need to emit &apos;close&apos; anyway so that the closing
  // of the stream is observable. We just make sure we
  // are not going to do it twice.
  // The &apos;close&apos; event is needed so that finished and
  // pipeline work correctly.
  if (!this._writableState.emitClose) {
    process.nextTick(() =&gt; {
      this.emit(&apos;close&apos;);
    });
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.process.stdout.destroySoon" id="apidoc.elem.istanbul-lite.process.stdout.destroySoon">
        function <span class="apidocSignatureSpan">istanbul-lite.process.stdout.</span>destroySoon
        <span class="apidocSignatureSpan">(err, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroy(err, cb) {
  const r = this._readableState;
  const w = this._writableState;

  if ((w &amp;&amp; w.destroyed) || (r &amp;&amp; r.destroyed)) {
    if (typeof cb === &apos;function&apos;) {
      cb();
    }

    return this;
  }

  if (err) {
    if (w) {
      w.errored = true;
    }
    if (r) {
      r.errored = true;
    }
  }

  // We set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (w) {
    w.destroyed = true;
  }
  if (r) {
    r.destroyed = true;
  }

  this._destroy(err || null, (err) =&gt; {
    if (err) {
      if (w) {
        w.errored = true;
      }
      if (r) {
        r.errored = true;
      }
    }

    if (w) {
      w.closed = true;
    }
    if (r) {
      r.closed = true;
    }

    if (typeof cb === &apos;function&apos;) {
      cb(err);
    }

    if (err) {
      process.nextTick(emitErrorCloseNT, this, err);
    } else {
      process.nextTick(emitCloseNT, this);
    }
  });

  return this;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>




























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.require" id="apidoc.module.istanbul-lite.require">module istanbul-lite.require</a></h1>


    <h2>
        <a href="#apidoc.elem.istanbul-lite.require.require" id="apidoc.elem.istanbul-lite.require.require">
        function <span class="apidocSignatureSpan">istanbul-lite.</span>require
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function require(path) {
  return mod.require(path);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
cwd: function () {
    return &quot;&quot;;
},
env: {}
};
require = function (key) {
try {
    return local[&quot;__istanbul_&quot; + key] || local[key] || local.<span class="apidocCodeKeywordSpan">require</span>(key);
} catch (ignore) {}
};
local[&quot;./package.json&quot;] = {};
// mock module path
local.__istanbul_path = local.path || {
dirname: function (file) {
    return file.replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.require.resolve" id="apidoc.elem.istanbul-lite.require.resolve">
        function <span class="apidocSignatureSpan">istanbul-lite.require.</span>resolve
        <span class="apidocSignatureSpan">(request, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve(request, options) {
  validateString(request, &apos;request&apos;);
  return Module._resolveFilename(request, mod, false, options);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
let fs;
// do nothing if module does not exist
try {
    fs = require(&quot;fs&quot;);
} catch (ignore) {
    return dflt;
}
pathname = require(&quot;path&quot;).<span class="apidocCodeKeywordSpan">resolve</span>(pathname);
// try to read pathname
try {
    return (
        type === &quot;json&quot;
        ? JSON.parse(fs.readFileSync(pathname, &quot;utf8&quot;))
        : fs.readFileSync(pathname, type)
    );
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.require.extensions" id="apidoc.module.istanbul-lite.require.extensions">module istanbul-lite.require.extensions</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.istanbul-lite.require.resolve" id="apidoc.module.istanbul-lite.require.resolve">module istanbul-lite.require.resolve</a></h1>


    <h2>
        <a href="#apidoc.elem.istanbul-lite.require.resolve.resolve" id="apidoc.elem.istanbul-lite.require.resolve.resolve">
        function <span class="apidocSignatureSpan">istanbul-lite.require.</span>resolve
        <span class="apidocSignatureSpan">(request, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve(request, options) {
  validateString(request, &apos;request&apos;);
  return Module._resolveFilename(request, mod, false, options);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
let fs;
// do nothing if module does not exist
try {
    fs = require(&quot;fs&quot;);
} catch (ignore) {
    return dflt;
}
pathname = require(&quot;path&quot;).<span class="apidocCodeKeywordSpan">resolve</span>(pathname);
// try to read pathname
try {
    return (
        type === &quot;json&quot;
        ? JSON.parse(fs.readFileSync(pathname, &quot;utf8&quot;))
        : fs.readFileSync(pathname, type)
    );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.istanbul-lite.require.resolve.paths" id="apidoc.elem.istanbul-lite.require.resolve.paths">
        function <span class="apidocSignatureSpan">istanbul-lite.require.resolve.</span>paths
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function paths(request) {
  validateString(request, &apos;request&apos;);
  return Module._resolveLookupPaths(request, mod);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
